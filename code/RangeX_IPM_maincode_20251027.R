# ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

# DATA ANALYSIS SCRIPT: FIRST IPM FIT ----

# ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

# ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

### Author              : Evelin Iseli
### Data used           : RangeX_ready_YS_IPM.csv (yearly size measurements of Swiss RangeX plants with added biomass from allometric models), RangeX_clean_RateGermination_2022_2023.csv
###                       (germination data from the two germination experiments), RangeX_clean_SeedNoGermination_2021_2022.csv (number of seeds per stick from the two germination experiments),
###                       RangeX_clean_BiomassSeedling_2023_2024.csv (seedling biomass from germonation exp2 and greenhouse)
### Date last modified  : 23.09.2025
### Purpose             : Fit life cycle models for IPMs. Model checking. Setting up vital rate functions.


# ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


rm(list = ls())

## PACKAGES etc. ---------------------------------------------------------------

# basic packages
library(dplyr); library(tidylog); library(janitor); library(tidyverse) # data manipulation
library(ggplot2)#; library(ggpattern) # plotting
library(stringr) # working with regex
library(data.table)
library(pbapply) # progress bar for apply

# task-specific packages (include short description of what it is used for)
library(car) # get vif to check collinearity
library(lme4) # mixed models
library(mgcv) # gam
library(MuMIn) # AICc
library(emmeans) # extracting coefficients
library(parallel); library(doParallel); library(foreach) # parallel computing

library(openxlsx) # save tables as excel

# plotting
library(patchwork)
library(grid)
library(scales) # symlog axis

source("/Users/eviseli/Documents/GitHub/RangeX_IPMs/code/RangeX_IPM_functions_mixed.R") # set to location of function file

# small functions

# function to get the opposite of %in%
`%nin%` <- Negate(`%in%`)

# function to extract legend from plot
g_legend <- function(a.gplot){
  tmp <- ggplot_gtable(ggplot_build(a.gplot))
  leg <- which(sapply(tmp$grobs, function(x) x$name) == "guide-box")
  legend <- tmp$grobs[[leg]]
  return(legend)
}


# plotting vectors
species_names <- c("brapin" = "Brachypodium\npinnatum", "broere" = "Bromus\nerectus", "daucar" = "Daucus\ncarota", "hypper" = "Hypericum\nperforatum", "medlup" = "Medicago\nlupulina", 
                   "plamed" = "Plantago\nmedia", "silvul" = "Silene\nvulgaris", "scacol" = "Scabiosa\ncolumbaria", "cenjac" = "Centaurea\njacea", "salpra" = "Salvia\npratensis")
species_labs <- c("brapin" = "B.\npinnatum", "broere" = "Bromus\nerectus", "daucar" = "Daucus\ncarota", "hypper" = "Hypericum\nperforatum", "medlup" = "Medicago\nlupulina", 
                   "plamed" = "Plantago\nmedia", "silvul" = "Silene\nvulgaris", "scacol" = "Scabiosa\ncolumbaria", "cenjac" = "Centaurea\njacea", "salpra" = "Salvia\npratensis")
site_labs <- c("lo" = "within-range", "hi" = "above-range")
treat_combi_labs <- c("bare.ambi" = "ambient - without competition", "bare.warm" = "warmed - without competition", 
                      "vege.ambi" = "ambient - with competition", "vege.warm" = "warmed - with competition")

# colour scheme
treat_combi_site_col <- c("hi_bare.ambi" = "#7ba491", "hi_bare.warm" = "#faa41b", "hi_vege.ambi" = "#3b5549", 
                          "hi_vege.warm" = "#875403", "lo_bare.ambi" = "#f15b4c", "lo_vege.ambi" = "#93180b")

treat_warm_site_col <- c("hi.ambi" = "#5B7D6D", "hi.warm" = "#C17C0F", "lo.ambi" = "#C23A2C")


## LOAD DATA -------------------------------------------------------------------

### data description -----------------------------------------------------------

# --> ready to use data is produced in RangeX_IPM_DataPrep_20241020.R

# - RangeX_clean_MetadataFocal_CHE.csv: metadata for the focal individuals (unique focal ID connected with treatments, planting date etc.)
# - RangeX_clean_MetadataPlot_CHE.csv: metadata for all experimental plots (unique plot ID connected with treatments etc.)
# - RangeX_ready_YS_IPM.csv: data frame containing the yearly size data as generated by RangeX_IPM_DataPrep_20241020.R based on the raw size and biomass data
# - RangeX_clean_RateGermination_2022_2023_CHE.csv: cleaned data on germination and establishment from the two germination experiments in 2021/22 and 2022/23
# - RangeX_clean_SeedNoGermination_2021_2022_CHE.csv: counted number of seeds per seed stick from the two germination experiments in 2021/22 and 2022/23
# - RangeX_clean_SeedlingBiomass_2023_2024_CHE.csv: seedling biomass from the germination experiment in 2022/23 plus the greenhouse grown extras in 2024
# - RangeX_ready_IS_IPM.csv: data frame containing the initial size data as generated by RangeX_IPM_DataPrep_20241020.R based on the raw size and biomass data
# - RangeX_clean_SeedTraits_2022_CHE.csv: seed traits measured on focal individuals in 2022 (no. seeds per seed head, seed weight)


dat_meta <- read_csv("data/raw/RangeX_clean_MetadataFocal_CHE.csv")
dat_meta_plot <- read_csv("data/raw/RangeX_clean_MetadataPlot_CHE.csv") %>%
  filter(added_focals == "wf")

dat_YS <- read_csv("data/derived/RangeX_ready_YS_IPM.csv")

dat_germ <- read_csv("data/raw/RangeX_clean_RateGermination_2022_2023_CHE.csv") # reads correctly
dat_sticks <- read_csv("data/raw/RangeX_clean_SeedNoGermination_2021_2022_CHE.csv") # reads correctly

dat_seedl <- read_csv("data/raw/RangeX_clean_SeedlingBiomass_2023_2024_CHE.csv") # reads correctly
dat_IS <- read_csv("data/derived/RangeX_ready_IS_IPM.csv")


# define data type
dat_YS <- dat_YS %>%
  mutate(across(c(survival, flower_status), as.factor),
         across(c(unique_plant_ID, species, functional_group), as.character),
         across(c(biomass_comb, number_seeds), as.numeric),
         across(c(date_planting), ~ as.Date(., format = "%Y-%m-%d")))
dat_IS <- dat_IS %>%
  mutate(across(c(flower_status), as.factor),
         across(c(unique_plant_ID, species, functional_group, collector), as.character),
         across(c(biomass, height_vegetative_str, number_leaves), as.numeric),
         across(c(date_planting, date_measurement), ~ as.Date(., format = "%Y-%m-%d")))


# save original loaded data
dat_YS_org <- dat_YS
dat_germ_org <- dat_germ
dat_sticks_org <- dat_sticks
dat_seedl_org <- dat_seedl
dat_IS_org <- dat_IS

### prepare size data frame ----------------------------------------------------

# use the three census years as replicates for growth variables
dat_growth_1 <- dat_YS %>% # t0 = 2021, t1 = 2022
  filter(year == 2021 | year == 2022) %>%
  dplyr::select(-date_measurement, -collector, -flower_status, -number_seeds) %>%  # ignore these columns
  pivot_wider(id_cols = c(unique_plant_ID, species, functional_group, date_planting),  # make wide
              names_from = year,  # use year column to create the new column names
              values_from = c(survival, biomass_comb, height_vegetative_str, number_leaves)) %>%
  rename("survival_t0" = "survival_2021", "survival" = "survival_2022",  "biomass_t0" = "biomass_comb_2021", "biomass_t1" = "biomass_comb_2022",
         "height_vegetative_str_t0" = "height_vegetative_str_2021", "height_vegetative_str_t1" = "height_vegetative_str_2022",
         "number_leaves_t0" = "number_leaves_2021", "number_leaves_t1" = "number_leaves_2022") %>%
  mutate(year_t0_biomass = 2021, 
         site = str_sub(unique_plant_ID, 5, 6))
  
dat_growth_2 <- dat_YS %>%
  filter(year == 2022 | year == 2023) %>% # t0 = 2022, t1 = 2023
  dplyr::select(-date_measurement, -collector, -flower_status, -number_seeds) %>%  # ignore these columns
  pivot_wider(id_cols = c(unique_plant_ID, species, functional_group, date_planting),  
              names_from = year,  # use year column to create the new column names
              values_from = c(survival, biomass_comb, height_vegetative_str, number_leaves)) %>%
  rename("survival_t0" = "survival_2022", "survival" = "survival_2023", "biomass_t0" = "biomass_comb_2022", "biomass_t1" = "biomass_comb_2023",
         "height_vegetative_str_t0" = "height_vegetative_str_2022", "height_vegetative_str_t1" = "height_vegetative_str_2023",
         "number_leaves_t0" = "number_leaves_2022", "number_leaves_t1" = "number_leaves_2023") %>%
  mutate(year_t0_biomass = 2022, 
         site = str_sub(unique_plant_ID, 5, 6))

dat_growth_3 <- dat_YS %>% 
  filter(year == 2023) %>% # t0 = 2023, t1 = 2024 (NA)
  dplyr::select(-date_measurement, -collector, -flower_status, -number_seeds) %>%  # ignore these columns
  pivot_wider(id_cols = c(unique_plant_ID, species, functional_group, date_planting),  
              names_from = year,  # use year column to create the new column names
              values_from = c(survival, biomass_comb, height_vegetative_str, number_leaves)) %>%
  rename("survival_t0" = "survival_2023", "biomass_t0" = "biomass_comb_2023",
         "height_vegetative_str_t0" = "height_vegetative_str_2023", 
         "number_leaves_t0" = "number_leaves_2023") %>%
  mutate(year_t0_biomass = 2023, survival = NA, biomass_t1 = NA, height_vegetative_str_t1 = NA,
         number_leaves_t1 = NA, 
         site = str_sub(unique_plant_ID, 5, 6))


# plot them all to see separation between years (a lot of growth in 2021 - 2022, stagnation/ shrinking in 2022 - 2023)
ggplot() +
  geom_point(data = dat_growth_1[is.na(dat_growth_1$biomass_t0) == FALSE & is.na(dat_growth_1$biomass_t0) == FALSE, ], aes (x = biomass_t0, y = biomass_t1), col = "darkgreen") +
  geom_point(data = dat_growth_2[is.na(dat_growth_2$biomass_t0) == FALSE & is.na(dat_growth_2$biomass_t0) == FALSE, ], aes (x = biomass_t0, y = biomass_t1), col = "darkblue") +
  #geom_point(data = dat_growth_3[is.na(dat_growth_3$biomass_t0) == FALSE & is.na(dat_growth_3$biomass_t0) == FALSE, ], aes (x = biomass_t0, y = biomass_t1), col = "darkred") +
  facet_wrap(site ~ species, scales = "free") +
  theme_bw() +
  geom_abline(slope = 1, intercept = 1) +
  ggtitle("Size_distribution_biomass")

# for some species, the year seems to be highly relevant for growth --> see "handling the year difference in growth data" for how to handle this

# use the three census years as replicates for reproductive variables
dat_rep <- dat_YS %>% # the measurement year is always t0 for the reproductive variables
  dplyr::select(-date_measurement, -collector, -biomass_comb, -height_vegetative_str, -number_leaves, -survival) %>%
  mutate(year_t0_biomass = year) %>%
  dplyr::select(-year)
  

# add wide data frames together for the complete data set
dat_YS_ready <- bind_rows(dat_growth_1, dat_growth_2, dat_growth_3) %>%
  left_join(dat_rep, by = c("unique_plant_ID", "functional_group", "date_planting", "year_t0_biomass", "species")) %>%
  mutate(treat_warm = str_sub(unique_plant_ID, 8, 11),
         treat_comp = str_sub(unique_plant_ID, 13, 16),
         site = str_sub(unique_plant_ID, 5, 6),
         across(starts_with("number_seeds"), ~ as.integer(round(., digits = 0)))) %>%
  mutate(number_seeds = ifelse(flower_status == 0, NA, number_seeds))  %>% # also all individuals with flower_status 0 should have an NA, not 0
  rename("survival" = "survival") %>%
  dplyr::select(c(1:4), site, treat_comp, treat_warm, survival, biomass_t0, biomass_t1, height_vegetative_str_t0, height_vegetative_str_t1, 
                number_leaves_t0, number_leaves_t1, flower_status, number_seeds) %>%
  mutate(across(starts_with("biomass"), log, .names = "{.col}_log"))

# model growth for all species & include year as a factor
dat_growth <- dat_YS %>%
  dplyr::select(-c(4:8, 10:12)) %>%
  group_by(unique_plant_ID) %>%
  arrange(unique_plant_ID, year) %>%
  mutate(biomass_log = log(biomass_comb),
         growth_2021_2022 = if_else(year == 2022, biomass_log - lag(biomass_log), NA_real_),
         growth_2022_2023 = if_else(year == 2023, biomass_log - lag(biomass_log), NA_real_)) %>%
  filter(year != 2021) %>%
  ungroup() %>%
  dplyr::select(-biomass_comb, -year, -biomass_log) %>%
  pivot_longer(cols = starts_with("growth"), 
               names_to = "growth_period",   
               values_to = "growth") %>%
  filter(!is.na(growth)) %>%
  mutate(site = str_sub(unique_plant_ID, 5, 6))

sites <- c("lo", "hi")

models_list <- list()
model_summaries <- data.frame(
  species = character(),
  site = character(),
  growth_period = character(),
  estimate = numeric(),
  std_error = numeric(),
  t_value = numeric(),
  p_value = numeric(),
  r_squared = numeric(),
  stringsAsFactors = FALSE)  

for (i in 1:length(species_names)) {
  for (j in 1:2) {
    
    # save infos
    species_now <- names(species_names)[i]
    site_now <- sites[j]
    
    # get data
    dat_current <- dat_growth[dat_growth$species == species_now & dat_growth$site == site_now, ]
    
    # model
    mod0 <- lm(growth ~ as.factor(growth_period), data = dat_current)
    
    # save
    mod_summary <- summary(mod0)
    model_name <- paste(species_now, site_now, sep = "_")
    models_list[[model_name]] <- mod0
    
    coef_table <- mod_summary$coefficients
    r_squared <- mod_summary$r.squared
    
    # save variables separately
    for (coef_row in 1:nrow(coef_table)) {
      coef_name <- rownames(coef_table)[coef_row]
      estimate <- coef_table[coef_row, "Estimate"]
      std_error <- coef_table[coef_row, "Std. Error"]
      t_value <- coef_table[coef_row, "t value"]
      p_value <- coef_table[coef_row, "Pr(>|t|)"]
      
      model_summaries <- rbind(model_summaries, data.frame(
        species = species_now,
        site = site_now,
        growth_period = coef_name,
        estimate = estimate,
        std_error = std_error,
        t_value = t_value,
        p_value = p_value,
        r_squared = r_squared))
      }
    }
  }

model_summaries_year <- model_summaries[model_summaries$growth_period == "as.factor(growth_period)growth_2022_2023",] %>%
  mutate(significance = if_else(p_value < 0.05, "sig", "non-sig."))

ggplot(data = dat_growth, aes(x = growth_period, y = growth, col = site)) +
  geom_boxplot() +
  facet_wrap(~species)

# year is significant in all species except daucar and salpra lo --> only use FIRST census for growth rate for all species (first because more individuals still alive)

# handling the year difference in growth data: 
# 1) as a standard, only the first census is used (i.e. use dat_growth_1 to define dat_YS_ready_small)
# 2) to double check, the models were also run using the second census (i.e. use dat_growth_2 to define dat_YS_ready_small and rerun the code identically)

# create a small data set where only the 2021/22 data is included (will be used later for growth, don't even add reproductive data)
dat_YS_ready_small <- dat_growth_1 %>%
  mutate(treat_warm = str_sub(unique_plant_ID, 8, 11),
         treat_comp = str_sub(unique_plant_ID, 13, 16),
         site = str_sub(unique_plant_ID, 5, 6)) %>%
  rename("survival" = "survival") %>%
  dplyr::select(c(1:4), site, treat_comp, treat_warm, survival, biomass_t0, biomass_t1, height_vegetative_str_t0, height_vegetative_str_t1, 
                number_leaves_t0, number_leaves_t1) %>%
  mutate(across(starts_with("biomass"), log, .names = "{.col}_log"))
#dat_YS_ready_small <- dat_growth_2 %>%
#  mutate(treat_warm = str_sub(unique_plant_ID, 8, 11),
#         treat_comp = str_sub(unique_plant_ID, 13, 16),
#         site = str_sub(unique_plant_ID, 5, 6)) %>%
#  rename("survival" = "survival") %>%
#  dplyr::select(c(1:4), site, treat_comp, treat_warm, survival, biomass_t0, biomass_t1, height_vegetative_str_t0, height_vegetative_str_t1, 
#                number_leaves_t0, number_leaves_t1) %>%
#  mutate(across(starts_with("biomass"), log, .names = "{.col}_log"))


# NAs in biomass_t0 while survival == 0: dead already year before
# NAs in biomass_t1 while survival == 0: died in this year
# NAs in biomass_t0 while survival == 1: measurement missing
# NAs in biomass_t1 while survival == 1: measurement missing


# rename biomass columns to size 
dat_YS_ready <- dat_YS_ready %>%
  rename("size_t0" = "biomass_t0", "size_t1" = "biomass_t1") %>%
  mutate(across(starts_with("size"), log, .names = "{.col}_log"))
dat_YS_ready_small <- dat_YS_ready_small %>%
  rename("size_t0" = "biomass_t0", "size_t1" = "biomass_t1") %>%
  mutate(across(starts_with("size"), log, .names = "{.col}_log"))


### prepare germination data frame ---------------------------------------------

dat_germ <- dat_germ_org 

dat_germ <- dat_germ %>%
  mutate(site = str_sub(germination_position_ID, 5, 6),
         exp = str_sub(germination_position_ID, 8, 11),
         treat_warm = str_sub(germination_position_ID, 13, 16),
         treat_comp = str_sub(germination_position_ID, 18, 21))

# germination = max. no seedlings ever germinated (independent of timepoint), establishment = presence at last check
# establishment = how many of the germinated seedlings survived until the end of the experiment? (same methods as in Hischier 2023)
## - https://www.theanalysisfactor.com/when-to-use-logistic-regression-for-percentages-and-counts/
## - https://stats.stackexchange.com/questions/103731/what-are-the-issues-with-using-percentage-outcome-in-linear-regression
## - https://www.flutterbys.com.au/stats/tut/tut10.5a.html


# make data frame wide again (seedling counts of different timepoints as columns) and make column with max count
dat_germ_wide <- dat_germ %>%
  dplyr::select(-date_measurement, -collector) %>%
  pivot_wider(names_from = "variable", values_from = "value") %>%
  rowwise() %>%
  mutate(max_count = max(autumn_count, spring_count, peak_count, na.rm = TRUE)) %>%
  filter(!(max_count == -Inf)) %>% # delete the row with NA values for all counts
  ungroup()


# germination of hypper in exp1 and the complete bare plot at lo in exp2 are unreliable and are therefore excluded and so are NAs
summary_germ <- dat_germ %>%
  filter(variable == "peak_count" & 
           !(species == "hypper" & exp == "exp1") & 
           !(exp == "exp2" & site == "lo") &
           is.na(value) == FALSE) %>%
  group_by(treat_comp, species) %>%
  summarise(non_zero_count = sum(value != 0)) # can either be calculated on the site level or on the comp_treatment level or both

# calculate average number of seeds per stick
summary_sticks <- dat_sticks %>%
  group_by(species, experiment) %>%
  summarize(mean_seedno = mean(seedcount),
            mean_seedno = round(mean_seedno, digits=0))

# filter out all not-wanted data in germination data frame, add mean number of seeds per stick and calculate germination rate
dat_germ_wide <- dat_germ_wide %>%
  filter(!(species == "hypper" & exp == "exp1") & 
           !(exp == "exp2" & site == "lo")) %>%
  left_join(summary_sticks, by = c("species", "exp" = "experiment")) %>%
  mutate(germ_rate = max_count/mean_seedno,
         germ_rate = ifelse(germ_rate > 1, 1, germ_rate)) # calculate germination rate & cap at 1!

# make a summary of the germination rates
summary_germ2 <- dat_germ_wide %>%
  group_by(site, treat_comp, species, treat_warm) %>% # , exp,
  summarise(mean_germrate = mean(germ_rate, na.rm = TRUE),
            non_zero_count = sum(max_count != 0))

dat_germ_ready <- dat_germ_wide %>%
  mutate(establishment = peak_count) # peak_count is defined as establishment

# one daucar stick with a very high germination compared to the mean_seedno --> take it out (23 germinated seedlings vs. 8 seeds on avergae)
dat_germ_ready <- dat_germ_ready %>%
  filter(!(max_count > mean_seedno)) # removed one row


### prepare seedling & initial size data frame ---------------------------------

# extract treatments etc. from seedling data
dat_seedl_ready <- dat_seedl %>%
  mutate(treat_warm = str_sub(germination_position_ID, 13, 16),
         treat_comp = str_sub(germination_position_ID, 18, 21),
         site = str_sub(germination_position_ID, 5, 6),
         exp = str_sub(germination_position_ID, 8, 11),
         size_t0_log = log(dry_mass))

# extract treatments etc. from initial size data
dat_IS_ready <- dat_IS %>%
  mutate(treat_warm = str_sub(unique_plant_ID, 8, 11),
         treat_comp = str_sub(unique_plant_ID, 13, 16),
         site = str_sub(unique_plant_ID, 5, 6),
         size_t0_log = log(biomass))

# count how many plants have an ID > 1 (those are the replaced plants - to calculate mortality before first winter)
dat_IS %>%
  mutate(index = str_sub(unique_plant_ID, -1)) %>%
  filter(index > 1) %>%
  summarize(count = n()) # 344

# mortality before first winter
100/1800 * 344 # 19.1111%

# count how many plants have been replaced within one week
dat_IS %>%
  mutate(index = str_sub(unique_plant_ID, -1)) %>%
  filter(index > 1 & date_planting < dmy("24.06.2021")) %>%
  summarize(count = n()) # 231

# mortality after first week
100/1800 * 231 # 12.83333%



# ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
# INTEGRATION LIMITS  ----
# ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

# find out the minimum and maximum size of each species * site * treatment combination to use as integration limits later

# use biomass from both seedlings, initial size and yearly size: first get rid of greenhouse seedlings and get out treatments

sizes_seedl <- dat_seedl_ready %>%
  filter(site != "gh") %>%
  dplyr::select(species, site, treat_warm, treat_comp, size_t0_log) %>%
  rename("biomass_log" = "size_t0_log")
sizes_IS <- dat_IS_ready %>%
  dplyr::select(species, site, treat_warm, treat_comp, size_t0_log) %>%
  rename("biomass_log" = "size_t0_log")
sizes_YS0 <- dat_YS_ready %>%
  dplyr::select(species, site, treat_warm, treat_comp, size_t0_log) %>%
  rename("biomass_log" = "size_t0_log")
sizes_YS1 <- dat_YS_ready %>%
  dplyr::select(species, site, treat_warm, treat_comp, size_t1_log) %>%
  rename("biomass_log" = "size_t1_log")
  

biomass_range <- bind_rows(sizes_seedl, sizes_IS, sizes_YS0, sizes_YS1)

biomass_range_summary <- biomass_range %>%
  group_by(species, site, treat_warm, treat_comp) %>%
  summarize(min_biomass = min(biomass_log, na.rm = TRUE),
            max_biomass = max(biomass_log, na.rm = TRUE)) %>%
  mutate(treat_combi = paste(treat_comp, treat_warm, sep = "."),
         max_biomass = max_biomass * 1.1,
         min_biomass = min_biomass * 0.9) # to avoid evicting individuals (Ellner 2016)


# ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
# VRF: MODEL DIAGNOSTICS ----
# ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

### LOOK AT DATA ---------------------------------------------------------------

# plot size distribution
ggplot(data = dat_YS_ready, aes(x = size_t0_log)) +
  geom_histogram() +
  facet_wrap(~species, nrow = 2, scales = "free") +
  scale_x_continuous(name = "log(Size at year t)") + 
  scale_y_continuous(name = "Count")
ggplot(data = dat_YS_ready, aes(x = size_t1_log)) +
  geom_histogram() +
  facet_wrap(~species, nrow=2, scales = "free") +
  scale_x_continuous(name = "Size at year t") + 
  scale_y_continuous(name="Count")

ggplot(data = dat_YS_ready_small, aes(x = biomass_t0_log, y = biomass_t1_log, col = site)) + # only use one census
  geom_point() +
  facet_wrap(~species, nrow = 2, scales = "free") +
  scale_x_continuous(name = "Size at year t0") + 
  scale_y_continuous(name = "Size at year t1") 

ggplot(data = dat_YS_ready_small, aes(x = biomass_t0_log, y = biomass_t1_log, col = treat_comp)) + # only use one census
  geom_point() +
  facet_wrap(~species, nrow = 2, scales = "free") +
  scale_x_continuous(name = "Size at year t0") + 
  scale_y_continuous(name = "Size at year t1") 


#### MODEL DIAGNOSTICS ----------------------------------------------------------
#
## This plotting & diagnostics is done on the species level, ignoring sites & treatments -> the structure detectable in the plots etc. 
## are mainly based on treatment effects, which will disappear once treatment-level modelling is implemented.
#
#species <- unique(dat_YS_ready$species)
#
##### survival probability ------------------------------------------------------
#
## get rid of NAs
#dat_surv <- dat_YS_ready %>%
#  group_by(species) %>%
#  filter(is.na(survival) == FALSE & is.na(size_t0_log) == FALSE) 
#
## plot
#par(mfrow = c(2, 5))
#
#for (i in 1:length(species)) {
#  specs <- species [i]
#  dat_surv_specs <- dat_surv[dat_surv$species == specs,]
#  
#  # model
#  surv.reg <- glm(survival ~ size_t0_log, data = dat_surv_specs, family = binomial(link = "logit"))
#  
#  # plot
#  plot(dat_surv_specs$size_t0_log, as.numeric(as.character(dat_surv_specs$survival)), main = paste("survival -", specs), xlab = "biomass", ylab = "survival")
#  xx <- seq(min(dat_surv_specs$size_t0_log), max(dat_surv_specs$size_t0_log), by = .01)
#  lines(xx, predict(surv.reg, data.frame(size_t0_log = xx), type="response"), col = "red", lwd = 3)
#  
#}
#  
#
## diagnostic plots
#pdf("/Users/eviseli/Documents/GitHub/RangeX_IPMs/plots/most_recent/diag_plots_surv.pdf", width = 10, height = 8)
#
#for(specs in c(species)) {
#  dat_surv %>%
#    filter(species == specs) %>%
#    plot.diag.glm("size_t0_log", "survival", data = ., fc = specs, mod.family = "binomial")
#}
#
#dev.off()
#
#
## linearity test
#linearity.sur <- dat_surv %>%
#  split(.$species) %>%
#  purrr::map_dfr(~linearity.glm(x = "size_t0_log", y = "survival", data = ., fc = unique(.$species), mod.family = "binomial"))
#
##### growth  -------------------------------------------------------------------
#
#
## get rid of NAs
#dat_growth <- dat_YS_ready %>%
#  filter(is.na(size_t0_log) == FALSE & is.na(size_t1_log) == FALSE) 
#
#
## plot
#par(mfrow = c(2, 5))
#
#for (i in 1:length(species)) {
#  specs <- species [i]
#  dat_growth_specs <- dat_growth[dat_growth$species == specs,]
#  
#  # model
#  growth.reg <- lm(size_t1_log ~ size_t0_log, data = dat_growth_specs)
#  
#  
#  # plot
#  plot(dat_growth_specs$size_t0_log, dat_growth_specs$size_t1_log, main = paste("growth -", specs), xlab = "size t", ylab = "size t+1")	
#  xx <- seq(min(dat_growth_specs$size_t0_log), max(dat_growth_specs$size_t0_log), by = .01)
#  lines(xx, predict(growth.reg, data.frame(size_t0_log = xx)), col = 'red', lwd = 3)
#  
#}
#
#
## diagnostic plots
#pdf("/Users/eviseli/Documents/GitHub/RangeX_IPMs/plots/most_recent/diag_plots_growth_census1.pdf", width = 10, height = 8)
##pdf("/Users/eviseli/Documents/GitHub/RangeX_IPMs/plots/most_recent/diag_plots_growth_census2.pdf", width = 10, height = 8)
#
#for(specs in c(species)) {
#  dat_growth %>%
#    filter(species == specs) %>%
#    plot.diag.lm(x = "size_t0_log", y = "size_t1_log", data = ., fc = specs)
#}
#
#dev.off()
#
#
## tests
#linearity.growth <- dat_growth %>%
#  split(.$species) %>%
#  purrr::map_dfr(~linearity.lm(x = "size_t0_log", y = "size_t1_log", data = ., fc = unique(.$species)))
#normality.growth <- dat_growth %>%
#  split(.$species) %>%
#  purrr::map_dfr(~normality.lm(x = "size_t0_log", y = "size_t1_log", data = ., fc = unique(.$species))) # doesn't look nice...
#constant.var.growth <- dat_growth %>%
#  split(.$species) %>%
#  purrr::map_dfr(~constant.var.lm(x = "size_t0_log", y = "size_t1_log", data = ., fc = unique(.$species)))
#
##### flowering probability -----------------------------------------------------
#
## get rid of NAs
#dat_flow <- dat_YS_ready %>%
#  group_by(species) %>%
#  filter(is.na(size_t0_log) == FALSE & is.na(flower_status) == FALSE) 
#
## plot
#par(mfrow = c(2, 5))
#
#for (i in 1:length(species)) {
#  specs <- species [i]
#  dat_flow_specs <- dat_flow[dat_flow$species == specs,]
#  
#  # model
#  flow.reg <- glm(flower_status ~ size_t0_log, data = dat_flow_specs, family = binomial(link = "logit"))
#  
#  # plot
#  plot(dat_flow_specs$size_t0_log, as.numeric(as.character(dat_flow_specs$flower_status)), main = paste("flower prob. -", specs), xlab = "biomass", ylab = "survival")
#  xx <- seq(min(dat_flow_specs$size_t0_log), max(dat_flow_specs$size_t0_log), by = .01)
#  lines(xx, predict(flow.reg, data.frame(size_t0_log = xx), type="response"), col = "red", lwd = 3)
#  
#}
#
#
## diagnostic plots
#pdf("/Users/eviseli/Documents/GitHub/RangeX_IPMs/plots/most_recent/diag_plots_flow.pdf", width = 10, height = 8)
#
#for(specs in c(species)) {
#  dat_flow %>%
#    filter(species == specs) %>%
#    plot.diag.glm("size_t0_log", "flower_status", data = ., fc = specs, mod.family = "binomial")
#}
#
#dev.off()
#
#
## linearity test
#linearity.flow <- dat_flow %>%
#  split(.$species) %>%
#  purrr::map_dfr(~linearity.glm(x = "size_t0_log", y = "flower_status", data = ., fc = unique(.$species), mod.family = "binomial"))
#
#
##### seed production -----------------------------------------------------------
#
## get rid of NAs
#dat_seed <- dat_YS_ready %>%
#  filter(is.na(size_t0_log) == FALSE & is.na(number_seeds) == FALSE) %>%
#  filter(flower_status != 0)
#
## plot
#par(mfrow = c(2, 5))
#
#for (i in 1:length(species)) {
#  specs <- species [i]
#  dat_seed_specs <- dat_seed[dat_seed$species == specs,]
#  
#  # model
#  seed.reg <- glm(number_seeds ~ size_t0_log, data = dat_seed_specs, family = poisson)
#
#  
#  # plot
#  plot(dat_seed$size_t0_log, dat_seed$number_seeds, main = paste("seed production -", specs), xlab = "size", ylab = "number of seeds")
#  xx <- seq(min(dat_seed$size_t0_log), max(dat_seed$size_t0_log), by = .01)
#  lines(xx, predict(seed.reg, data.frame(size_t0_log = xx), type = "response"), col="red", lwd=3)
#  
#}
#
## looks like bad fit --> will be better once treatments are included
#
#
## diagnostic plots
#pdf("/Users/eviseli/Documents/GitHub/RangeX_IPMs/plots/most_recent/diag_plots_seed.pdf", width = 10, height = 8)
#
#for(specs in c(species)) {
#  dat_seed %>%
#    filter(species == specs) %>%
#    plot.diag.glm("size_t0_log", "number_seeds", data = ., fc = specs, mod.family = "poisson")
#}
#
#dev.off()
#
#
## tests
#linearity.seed <- dat_seed %>%
#  split(.$species) %>%
#  purrr::map_dfr(~linearity.glm(x = "size_t0_log", y = "number_seeds", data = ., fc = unique(.$species), mod.family = "poisson"))
#
#
## those tests are on combined data of all treatments - what looks like bad fit will improve once treatments are included

# ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
# VRF: MODEL SELECTION  ----
# ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


# add block and plotID to the used data frames for size-dependent modelling to make mixed models possible
cols_small <- colnames(dat_YS_ready_small)

dat_YS_ready_small_mixed <- dat_YS_ready_small %>%
  left_join(dat_meta, by = c("unique_plant_ID", "species", "functional_group", "date_planting", "site")) %>%
  dplyr::select(all_of(cols_small), block_ID, plot_ID_original)

cols <- colnames(dat_YS_ready)

dat_YS_ready_mixed <- dat_YS_ready %>%
  left_join(dat_meta, by = c("unique_plant_ID", "species", "functional_group", "date_planting", "site")) %>%
  dplyr::select(all_of(cols), block_ID, plot_ID_original)


# same for size-independent modelling

# as the germination data is based on two different experiments, plot ID needs to be reconstructed based on treatments for experiment 1 and "invented" for experiment 2

cols_germ <- colnames(dat_germ_ready)

# create unique_plot_id
dat_germ_ready_mixed <- dat_germ_ready %>%
  separate(germination_position_ID, 
    into = c("region","site","exp","treat_warming","treat_competition","block_ID","position"),
    sep = "\\.", remove = FALSE) %>%
  left_join(dat_meta_plot, by = c("region", "site", "treat_warming", "treat_competition", "block_ID")) %>% # this only works for exp 1, for exp 2 the plot id's have to be manually specified
  mutate(block_ID = ifelse(exp == "exp2", "11", block_ID),
         block_ID_original = ifelse(exp == "exp2", 11, block_ID_original),
         plot_ID_original = case_when(exp == "exp2" & site == "hi" & treat_warming == "warm" & treat_competition == "vege" ~ 1,
                                      exp == "exp2" & site == "hi" & treat_warming == "warm" & treat_competition == "bare" ~ 2,
                                      exp == "exp2" & site == "hi" & treat_warming == "ambi" & treat_competition == "vege" ~ 3,
                                      exp == "exp2" & site == "hi" & treat_warming == "ambi" & treat_competition == "bare" ~ 4,
                                      exp == "exp2" & site == "lo" & treat_warming == "ambi" & treat_competition == "vege" ~ 1,
                                      exp == "exp2" & site == "lo" & treat_warming == "ambi" & treat_competition == "bare" ~ 2,
                                      TRUE ~ plot_ID_original)) %>%
  dplyr::select(all_of(cols_germ), block_ID, plot_ID_original)

### MODEL SELECTION WITH AICc --------------------------------------------------

#### size-dependent models -----------------------------------------------------

# define different full models for both sites (full models differ between sites (no warming treatment at low site) plus for seed production for some species not enough data on the species * treatments * site level)
full.mod.bcw <- c("treat_warm * treat_comp * size_t0_log")
full.mod.bcw.min <- c("treat_warm + treat_comp + size_t0_log + treat_warm:treat_comp + treat_comp:size_t0_log + treat_warm:size_t0_log")
full.mod.bc <- c("treat_comp * size_t0_log")
full.mod.bw <- c("treat_warm * size_t0_log")
full.mod.b <- c("size_t0_log")


# SIZE DEPENDENT VITAL RATES

# If there's a really low number of data points in a species * site combination (especially for number_seeds), non-parametric bootstrapping won't work with treatments included as a factor 
# as there will inevitably be an iteration where only values of one treatment are included --> use less complicated models for these combinations when non-parametric bootstrapping wanted.

# GROWTH MODELS:
# To prevent negative growth functions for some of the species * site *treatment combinations caused by the much lower growth
# in 2023, only the 2022/23 data is used for growth modelling.

# function to define full models and model specifications 
# special cases:
# - full model is not possible for salpra hi reproduction models, as no flowering individuals in vegetation --> use smaller model for that
# - full model is also no possible for brapin, plamed and silvul lo for flowering: too few flowering individuals in the vege treatment for the interaction
# - full model also not possible for broere lo for survival: no dead individuals in vege


select.model.data.sd <- function(species, site, vital_rate) {
  if (vital_rate == "number_seeds") {
    if (site == "hi" && species == "salpra") {
      return(list(candidate = full.mod.bw, mod.family = "poisson"))
    } else if (site == "hi" && species != "salpra") {
      return(list(candidate = full.mod.bcw, mod.family = "poisson"))
    } else if (site == "lo") {
      return(list(candidate = full.mod.bc, mod.family = "poisson"))
    } 
  } else if (vital_rate == "size_t1_log") {
    if (site == "hi") {
      return(list(candidate = full.mod.bcw, mod.family = "gaussian"))
    } else if (site == "lo") {
      return(list(candidate = full.mod.bc, mod.family = "gaussian"))
    } 
  } else if (vital_rate == "flower_status") {
    if (site == "hi") {
      return(list(candidate = full.mod.bcw, mod.family = "binomial"))
    } else if (site == "lo") {
      if (species %in% c("brapin", "plamed", "silvul")) {
        return(list(candidate = full.mod.b, mod.family = "binomial"))
      } else {
        return(list(candidate = full.mod.bc, mod.family = "binomial"))
      }
    }
  } else if (vital_rate == "survival") {
    if (site == "hi") {
      return(list(candidate = full.mod.bcw, mod.family = "binomial"))
    } else if (site == "lo") {
      if (species == "broere") {
        return(list(candidate = full.mod.b, mod.family = "binomial"))
      } else {
        return(list(candidate = full.mod.bc, mod.family = "binomial"))
      }
    }
  }
}



# now fit all the models, dependent on species, site etc.

vital_rates <- c("survival", "size_t1_log", "flower_status", "number_seeds")
sites <- c("lo", "hi")
results_list <- list()

for (response_var in vital_rates) {
  
  print(response_var)
  
  for (i in 1:2) {
    site.def <- sites[i]
    
    if (response_var == "size_t1_log") {
      
      dat_subset <- dat_YS_ready_small_mixed %>% # use only small data set for growth models
        filter(site == site.def & !is.na(size_t0_log))
    } else{
      dat_subset <- dat_YS_ready_mixed %>%
        filter(site == site.def & !is.na(size_t0_log))
    }
    
    grouped_data <- dat_subset %>%
      #filter(species != "salpra") %>%
      group_by(species, site) %>%
      nest()
    
    model_selection <- grouped_data %>%
      mutate(model_info      = map(species, ~select.model.data.sd(.x, site.def, response_var)),
             candidate_model = map_chr(model_info, ~ .x$candidate),
             
             model_outputs   = map2(data, model_info, ~ modelcmp.glm.mixed(
               data      = .x,
               response  = response_var,
               candidate = .y$candidate,
               mod.family= .y$mod.family)),
             
             dredge_output   = map(model_outputs, "dredge_output"),
             best_model      = map(model_outputs, "best_model"),
             
             best_model_predictors = map_chr(best_model,
                                             ~ if (is.null(.x)) NA_character_
                                             else paste(attr(terms(.x), "term.labels"), collapse = " + ")),
             
             chosen_aicc     = map_dbl(model_outputs, "chosen_aicc"),
             delta_aicc      = map_dbl(model_outputs, "chosen_delta_aicc"),
             N_size          = map_dbl(model_outputs, "N_no"),
             re_used         = map_chr(model_outputs, "re_used"),
             fit_status      = map_chr(model_outputs, "fit_status"),
             fit_message     = map_chr(model_outputs, "fit_message"),
             vital_rate      = response_var,
             site            = site.def) %>%
      ungroup()
    
    

    
    results_list[[paste(response_var, site.def)]] <- model_selection
    }
}

# the convergence issues for medlup hi growth can be ignored as the final selected best model doesn't have them anymore

# add tibles of different vital rates together
final_results_sd <- bind_rows(results_list, .id = "source") %>% # it's 80 models (10 species * 2 sites * 4 vital rates)
  mutate(site = str_sub(source, start = -2))


# create a clean data frame
final_summary <- final_results_sd %>%
  dplyr::select(vital_rate, species, site, best_model_predictors, chosen_aicc, delta_aicc, N_size, candidate_model, re_used, fit_status, fit_message)


# save as excel
write.xlsx(final_summary, file = "output/IPM_modelselection_sizedependent_20251027_mixed_census1.xlsx", rowNames = FALSE)
#write.xlsx(final_summary, file = "output/IPM_modelselection_sizedependent_20250929_mixed_census2.xlsx", rowNames = FALSE)


#### size-independent models ---------------------------------------------------

# Depending on the amount of data collected for the different species, different full models are considered:
# - default: include treat_comp
# - only intercept for scacol (overall very low germination) and hypper (data of exp1 not useable and therefore no germination at site lo)

# define different full models 
full.mod.cw <- c("treat_comp * treat_warm")
full.mod.c <- c("treat_comp")
full.mod.w <- c("treat_warm")
full.mod.1 <- c("1")


# GERMINATION & ESTABLISHMENT RATE

# quick check for which species treat_warm can be included for germination (use less complex model if n < 3)
germ_summary <- dat_germ_ready %>%
  group_by(species, site, treat_comp, treat_warm) %>%
  summarize(non_zero_count = sum(germ_rate != 0))

# full model at lo site (full.mod.c) not possible for hypper --> use full.mod.1 as only germination in bare soil plots
# full model at hi site (full.mod.cw) not possible for: hypper  --> full.mod.c

# quick check for which species treat_warm can be included for establishment
est_summary <- dat_germ_ready %>%
  group_by(species, site, treat_comp, treat_warm) %>%
  summarize(non_zero_count = sum(establishment != 0, na.rm = TRUE))

est_summary_low <- filter(est_summary, species %in% c("hypper", "plamed", "scacol") & site == "hi")

# full model at lo site (full.mod.c) not possible for: brapin, hypper, scacol, plamed, silvul, medlup --> use full.mod.1 as only establishment in one plot type
# full model at hi site (full.mod.cw) not possible for: hypper, plamed, scacol  
### --> full.mod.1 for hypper as only establishment in bare.ambi
### --> full.mod.c for plamed and scacol as not enough establishment in warmed plots

# function to select and define full models depending on model type and data availability
select.model.data.sid <- function(species, site, vital_rate) {
  if (vital_rate == "germ_rate") {
    if (species == "hypper" && site == "lo") {
      return(list(candidate = full.mod.1, mod.family = "binomial"))
    } else if (species == "hypper" && site == "hi") {
      return(list(candidate = full.mod.c, mod.family = "binomial"))
    } else if (site == "lo" && species != "hypper") {
      return(list(candidate = full.mod.c, mod.family = "binomial"))
    } else {
      return(list(candidate = full.mod.cw, mod.family = "binomial"))
    }
  } else if (vital_rate == "establishment") {
    if (species %in% c("brapin", "hypper", "scacol", "plamed", "silvul", "medlup") && site == "lo") {
      return(list(candidate = full.mod.1, mod.family = "binomial"))
    } else if (species == "hypper" && site == "hi") {
      return(list(candidate = full.mod.1, mod.family = "binomial"))
    } else if (species %in% c("plamed", "scacol") && site == "hi") {
      return(list(candidate = full.mod.c, mod.family = "binomial"))
    } else if (site == "lo") {
      return(list(candidate = full.mod.c, mod.family = "binomial"))
    } else {
      return(list(candidate = full.mod.cw, mod.family = "binomial"))
    }
  }
}

# now fit all the models
vital_rates_sid <- c("germ_rate", "establishment")
sites <- c("lo", "hi")
results_list_sid <- list()


# now fit all the models
vital_rates_sid <- c("germ_rate", "establishment")
sites <- c("lo", "hi")
results_list_sid <- list()

for (response_var in vital_rates_sid) {
  for (i in 1:2) {
    site.def <- sites[i]
    
    # create dataset subset for germination and establishment
    if (response_var == "germ_rate") {
      dat_subset <- dat_germ_ready_mixed %>%
        dplyr::filter(site == site.def & !is.na(max_count) & !is.na(mean_seedno))
    } else if (response_var == "establishment") {
      dat_subset <- dat_germ_ready_mixed %>%
        dplyr::filter(site == site.def & !is.na(peak_count) & !is.na(max_count))
    }
    
    grouped_data <- dat_subset %>%
      dplyr::group_by(species, site) %>%
      tidyr::nest()
    
    model_selection <- grouped_data %>%
      dplyr::mutate(
        # select full model and family depending on species/site/vital rate
        model_info      = purrr::map(species, ~select.model.data.sid(.x, site.def, response_var)),
        candidate_model = purrr::map_chr(model_info, ~ .x$candidate),
        
        # precompute response matrix for binomial two-column form
        response_matrix = purrr::map(
          data,
          ~{
            if (response_var == "germ_rate") {
              mat <- cbind(success = .x$max_count,
                           failure = .x$mean_seedno - .x$max_count)
            } else if (response_var == "establishment") {
              mat <- cbind(success = .x$peak_count,
                           failure = .x$max_count - .x$peak_count)
            } else {
              stop("Unknown response_var in size-independent loop.")
            }
            colnames(mat) <- c("success", "failure")
            mat
          }
        ),
        
        # get model selection and utput: block+plot -> block -> FE
        model_outputs = purrr::pmap(
          list(data = data, response_matrix = response_matrix, mi = model_info),
          function(data, response_matrix, mi) {
            modelcmp.glm.mixed_matrix(
              data            = data,
              response_matrix = response_matrix,
              candidate       = mi$candidate,
              mod.family      = mi$mod.family
            )
          }
        ),
        
        dredge_output = purrr::map(model_outputs, "dredge_output"),
        best_model    = purrr::map(model_outputs, "best_model"),
        best_model_predictors = purrr::map_chr(
          best_model,
          ~ if (is.null(.x)) NA_character_
          else paste(attr(terms(.x), "term.labels"), collapse = " + ")
        ),
        chosen_aicc   = purrr::map_dbl(model_outputs, "chosen_aicc"),
        delta_aicc    = purrr::map_dbl(model_outputs, "chosen_delta_aicc"),
        N_size        = purrr::map_dbl(model_outputs, "N_no"),
        
        # new: random-effects info (from mixed matrix function)
        re_used       = purrr::map_chr(model_outputs, "re_used"),
        fit_status    = purrr::map_chr(model_outputs, "fit_status"),
        fit_message   = purrr::map_chr(model_outputs, "fit_message"),
        
        vital_rate    = response_var,
        site          = site.def
      ) %>%
      dplyr::ungroup()
    
    results_list_sid[[paste(response_var, site.def)]] <- model_selection
  }
}

# add the tibbles together
final_results_sid <- bind_rows(results_list_sid) # it's 38 models (10 species * 2 vital rates * 2 sites minus hypper at lo site)


# create a clean data frame
final_summary_sid <- final_results_sid %>%
  dplyr::select(vital_rate, site, species, best_model_predictors, chosen_aicc, delta_aicc, N_size, candidate_model, re_used, fit_status, fit_message)

# save as excel
write.xlsx(final_summary_sid, file = "output/IPM_modelselection_sizeINdependent_20251027_mixed.xlsx", rowNames = FALSE)


# RECRUIT SIZE

# no model selection for recruit size as this will be just the mean and sd of seedling size

### MODEL DIAGNOSTICS FINAL MODELS ---------------------------------------------


#### survival probability ------------------------------------------------------

final_results_survival <- final_results_sd[final_results_sd$vital_rate == "survival",]

pdf("plots/diag_plots_survival_final.pdf")

# loop through each row of the data frame
for (i in seq_len(nrow(final_results_survival))) {
  # extract the model and data from the current row
  mod.test <- final_results_survival$best_model[[i]]
  data <- final_results_survival$data[[i]]  # make it a data frame
  species_name <- final_results_survival$species[[i]]
  site_name <- final_results_survival$site[[i]]
  
  # define column names
  x_column_name <- "size_t0_log"
  y_column_name <- "survival"  
  
  # plot
  plot.diag.glm.mod(mod.test = mod.test, x = x_column_name, y = y_column_name, 
                    data = data, fc = species_name, site = site_name, mod.family = "binomial")
}

dev.off()

#### growth --------------------------------------------------------------------

final_results_biomass <- final_results_sd[grepl("size_t1_log", final_results_sd$source),]

pdf("plots/diag_plots_growth_final_census1.pdf")
#pdf("plots/diag_plots_growth_final_census2.pdf")

# loop through each row of the data frame
for (i in seq_len(nrow(final_results_biomass))) {
  # extract the model and data from the current row
  mod.test <- final_results_biomass$best_model[[i]]
  data <- final_results_biomass$data[[i]]  # make it a data frame
  species_name <- final_results_biomass$species[[i]]
  site_name <- final_results_biomass$site[[i]]
  
  # define column names
  x_column_name <- "size_t0_log"  
  y_column_name <- "size_t1_log"  
  
  # plot
  plot.diag.glm.mod(mod.test = mod.test, x = x_column_name, y = y_column_name, 
                   data = data, fc = species_name, site = site_name, mod.family = "gaussian")
}

dev.off()


#### flowering probability -----------------------------------------------------

final_results_flow <- final_results_sd[grepl("flower", final_results_sd$source),]

pdf("plots/diag_plots_flowering_final.pdf")

# loop through each row of the data frame
for (i in seq_len(nrow(final_results_flow))) {
  # extract the model and data from the current row
  mod.test <- final_results_flow$best_model[[i]]
  data <- final_results_flow$data[[i]]  # make it a data frame
  species_name <- final_results_flow$species[[i]]
  site_name <- final_results_flow$site[[i]]
  
  # define column names
  x_column_name <- "size_t0_log"  
  y_column_name <- "flower_status"  
  
  # plot
  plot.diag.glm.mod(mod.test = mod.test, x = x_column_name, y = y_column_name, 
                   data = data, fc = species_name, site = site_name, mod.family = "binomial")
}

dev.off()


#### seed production -----------------------------------------------------------

final_results_seed <- final_results_sd[grepl("seed", final_results_sd$source),]

pdf("plots/diag_plots_seeds_final.pdf")

# loop through each row of the data frame
for (i in seq_len(nrow(final_results_seed))) {
  # extract the model and data from the current row
  mod.test <- final_results_seed$best_model[[i]]
  data <- final_results_seed$data[[i]]  # make it a data frame
  species_name <- final_results_seed$species[[i]]
  site_name <- final_results_seed$site[[i]]
  
  # define column names
  x_column_name <- "size_t0_log"  
  y_column_name <- "number_seeds"  
  
  # plot
  plot.diag.glm.mod(mod.test = mod.test, x = x_column_name, y = y_column_name, 
                    data = data, fc = species_name, site = site_name, mod.family = "poisson")
}

dev.off()


# ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
# VRF: MODEL COEFFICIENTs  ----
# ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

# This extraction of coefficients uses the emmeans package which predicts on a reference grid based on provided model, rather than releveling and refitting models.

#### size-dependent models -----------------------------------------------------

# initialize a data frame to store results
vr_long_sd <- data.frame()

# loop through each row of final_results_sd
for (i in seq_len(nrow(final_results_sd))) {
  
  # step 1: extract the best model and data
  best_model <- final_results_sd$best_model[[i]]
  model_formula <- formula(best_model)
  model_family <- stats::family(best_model) 
  
  current_data <- final_results_sd$data[[i]] %>%
    mutate(treat_comp = as.factor(treat_comp),
           treat_warm = as.factor(treat_warm))
  
  ## step 2: set up data frame
  #temp_results <- data.frame(site = character(), species = character(), vital_rate = character(), N_size = numeric(), slope = numeric(), intercept = numeric(), se = numeric(),
  #  sigma = numeric(), treat_combi = character(), stringsAsFactors = FALSE)
  temp_results <- data.frame()
  
  # step 3: determine site and treatment combinations and set up a temporary data frame
  site <- final_results_sd[i, "site"]
  species <- final_results_sd[i, "species"]
  vital_rate <- final_results_sd[i, "vital_rate"]
  N_size <- final_results_sd[i, "N_size"]
  
  # fill in treatment combinations based on the site
  if (site == "lo") {
    temp_results <- rbind(temp_results, data.frame(
      site = site,
      species = species,
      vital_rate = vital_rate,
      N_size = N_size,
      slope = NA,      
      intercept = NA,
      se.intercept = NA,
      se.slope = NA,
      sigma = NA,
      treat_combi = c("bare.ambi", "vege.ambi"),
      stringsAsFactors = FALSE
    ))
  } else if (site == "hi") {
    temp_results <- rbind(temp_results, data.frame(
      site = site,
      species = species,
      vital_rate = vital_rate,
      N_size = N_size,
      slope = NA,
      intercept = NA,
      se.intercept = NA,
      se.slope = NA,
      sigma = NA,
      treat_combi = c("bare.ambi", "bare.warm", "vege.ambi", "vege.warm"),
      stringsAsFactors = FALSE
    ))
  }
  
  # step 4: extract intercepts/slopes via emmeans --> extract which coefficients are used in this best_model
  
  # if the best model is NULL (shouldn't b e the case) 
  if (is.null(best_model)) {
    vr_long_sd <- rbind(vr_long_sd, temp_results) # append results data frame with NA filled row from temp_results
    next
  }
  
  # population-level predictions for mixed models
  re_form_arg <- if (inherits(best_model, "merMod")) NA else NULL # set random structure to NA if best_model is a merMod object and to NULL if it isn't
  
  # which fixed terms are present?
  fixed_terms <- attr(terms(best_model), "term.labels")
  has_comp <- any(grepl("^treat_comp", fixed_terms)) # is competition in the model?
  has_warm <- any(grepl("^treat_warm", fixed_terms)) # is warming in the model?
  has_size <- any(grepl("size_t0_log", fixed_terms)) # is size_t0_log in the model?
  
  # emmeans specifications that matches the fitted fixed effects
  specs <- if (has_comp && has_warm) {
    ~ treat_comp * treat_warm
  } else if (has_comp) {
    ~ treat_comp
  } else if (has_warm) {
    ~ treat_warm
  } else {
    ~ 1
  }
  
  # step 5: calculate intercepts/slopes via emmeans --> actually extract the values of the used coefficients
  
  # a) calculate intercepts at size_t0_log = 0 (on link scale)
  emm_df <- as.data.frame(
    emmeans::emmeans(
      best_model, specs,
      at = list(size_t0_log = 0),
      re.form = re_form_arg, # NULL for models with no random structure, NA for models with random structure (NA --> use marginal/ population level estimates)
      type = "link"
    )
  )
  if (!("treat_comp" %in% names(emm_df))) emm_df$treat_comp <- NA # set treat_comp to NA if not in best_model
  if (!("treat_warm" %in% names(emm_df))) emm_df$treat_warm <- NA # set treat_warm to NA if not in best_model
  
  # b) calculate slopes according to size_t0_log (if size is in the model)
  slopes_df <- NULL
  if (has_size) { # get slope only if size is incloded in best_model
    tr_obj <- try( # prevent crashing if emtrends fails
      # compute slope (partial derivative) of the linear predictor (type = "link") with respect to size_t0_log, for each level combination in specs
      emmeans::emtrends(
        best_model, specs, var = "size_t0_log",
        re.form = re_form_arg, type = "link"
      ),
      silent = TRUE
    )
    if (!inherits(tr_obj, "try-error")) { # if there was no error and emtrends did not fail, continue with writing the results
      slopes_df <- as.data.frame(tr_obj)
      if (!("treat_comp" %in% names(slopes_df))) slopes_df$treat_comp <- NA # set treat_comp to NA if not in best_model
      if (!("treat_warm" %in% names(slopes_df))) slopes_df$treat_warm <- NA # set treat_warm to NA if not in best_model
    }
  }
  
  # function: helper to pick the right row for a treatment combination from the emmeans/emtrends results table (df = emmeans/emtrends results data frame)
  pick_row <- function(df, comp_lvl, warm_lvl, use_comp, use_warm) {
    dd <- df
    if (use_comp) dd <- dd[dd$treat_comp == comp_lvl, , drop = FALSE] # if comp is included in model (use_comp == TRUE), filter the df (emmeans/ emmtrends results) to this level (i.e. vege or bare)
    if (use_warm) dd <- dd[dd$treat_warm == warm_lvl, , drop = FALSE] # if warm is included in model (use_warm == TRUE), filter the df (emmeans/ emmtrends results) to this level (i.e. warm or ambi)
    if (nrow(dd) == 0) dd <- df[1, , drop = FALSE] # fallback if filtering didn't work (returns first row of df while keeping it in a data frame structure (drop = FALSE))
    dd # return filtered data frame
  }
  
  # step 6: loop through each row in temp_results to extract and fill in correct slopes, intercepts etc.
  for (j in 1:nrow(temp_results)) {
    current_treatcomp <- substr(temp_results$treat_combi[j], 1, 4)   # "bare"/"vege"
    current_treatwarm <- substr(temp_results$treat_combi[j], 6, 9)   # "ambi"/"warm"
    
    # intercept + SE
    dd_int <- pick_row(emm_df, current_treatcomp, current_treatwarm, has_comp, has_warm) # use pick_row function to extract results from emm_df
    temp_results$intercept[j]    <- dd_int$emmean # save intercept
    temp_results$se.intercept[j] <- dd_int$SE # save se for intercept
    
    # slope + SE (if available)
    if (!is.null(slopes_df)) { # if there is a slope...
      dd_slp <- pick_row(slopes_df, current_treatcomp, current_treatwarm, has_comp, has_warm) # ...use pick_row function to extract results from slopes_df
      slope_col <- if ("size_t0_log" %in% names(dd_slp)) "size_t0_log" else
        if ("trend" %in% names(dd_slp)) "trend" else
          names(dd_slp)[which(names(dd_slp) %in% c("size_t0_log.trend","slope"))[1]] # emtrends returns df's with different column names --> check which one was used in the current model to use it correctly
      temp_results$slope[j]    <- dd_slp[[slope_col]] # save slope
      temp_results$se.slope[j] <- dd_slp$SE # save se for slope
    } else { # if there's no slope, just add NA
      temp_results$slope[j]    <- NA_real_
      temp_results$se.slope[j] <- NA_real_
    }
  }
  
  # sigma only for Gaussian growth
  vital_rate <- final_results_sd$vital_rate[i] # make vital rate from a tibble into character string
  sig <- NA_real_
  
  if (inherits(best_model, "lmerMod")) {
    # Gaussian LMM
    sig <- sigma(best_model)
  } else if (inherits(best_model, "glm")) {
    # GLM: keep sigma only if Gaussian family
    fam <- tryCatch(stats::family(best_model), error = function(e) NULL)
    if (!is.null(fam) && identical(fam$family, "gaussian")) {
      sig <- sigma(best_model)
    }
    # (binomial/poisson GLMs -> leave NA)
  }
  # glmerMod (binomial/poisson) -> leave NA
  
  # only keep sigma for growth
  if (vital_rate == "size_t1_log") {
    temp_results$sigma <- sig
  } else {
    temp_results$sigma <- NA_real_
  }

  
  # step 7: add temporary results to the permanent dataframe
  vr_long_sd <- rbind(vr_long_sd, temp_results)
}

# The "NOTE" can be ignored: It is a reminder that whenever someone asks for marginal means or trends of a factor that also appears in an interaction in the fitted model, 
# the “main effect” of that factor isn’t a single, universal number—it depends on the other variables it interacts with. BUT: Code explicitly request intercepts
# at a specific size, group-wise means and group-wise slopes, so this is handled.

## dealing with the warnings:
## - for survival for broere lo, the models don't converge when treat_comp is included as a model variable (then there's no death for the vege treatment)
## - for flower_status for brapin, plamed and silvul lo, there's probabilities of 0 or 1 (there's for all mainly bare flowering and only very few vege)

# --> don't use interaction for groups with less than 5 individuals

# add  best models back on to see whether all necessary coefficients were calculated
vr_long_sd_check <- vr_long_sd %>%
  left_join(final_summary, by = c("vital_rate", "species", "site")) # looks good!

#### recruit size -----------------------------------------------------

# prepare data
dat_IS_ready2 <- dat_IS_ready %>%
  dplyr::select(species, size_t0_log)


# get mean and sd on the species level (not possible to get it on a site or treatment level as greenhouse plants are included)
dat_seedl_ready2 <- dat_seedl_ready %>%
  dplyr::select(species, size_t0_log) %>%
  bind_rows(dat_IS_ready2) 
pre_vr_recruit <- dat_seedl_ready2  %>%
  group_by(species) %>%
  summarize(r_mean = mean(size_t0_log, na.rm = TRUE),
            r_sd = sd(size_t0_log, na.rm = TRUE),
            N_size = n())


#### size-independent models ---------------------------------------------------

# initialize a data frame to store results
vr_long_sid <- data.frame()

# loop through each row of final_results_sd
for (i in seq_len(nrow(final_results_sid))) {
  
  # step 1: extract the best model and data
  best_model   <- final_results_sid$best_model[[i]]
  model_formula <- stats::formula(best_model)
  model_family <- stats::family(best_model) 
  
  current_data <- final_results_sid$data[[i]] %>%
    dplyr::mutate(treat_comp = as.factor(treat_comp),
                  treat_warm = as.factor(treat_warm))
  
  ## step 2: set up data frame
  temp_results <- data.frame()
  
  # step 3: determine site and treatment combinations and set up a temporary data frame
  site       <- final_results_sid$site[i]      
  species    <- final_results_sid$species[i]
  vital_rate <- final_results_sid$vital_rate[i]
  N_size     <- final_results_sid$N_size[i]
  
  # fill in treatment combinations based on the site
  if (site == "lo") {
    temp_results <- rbind(temp_results, data.frame(
      site = site,
      species = species,
      vital_rate = vital_rate,
      N_size = N_size,
      intercept = NA,
      se.intercept = NA,
      treat_combi = c("bare.ambi", "vege.ambi"),
      stringsAsFactors = FALSE
    ))
  } else if (site == "hi") {
    temp_results <- rbind(temp_results, data.frame(
      site = site,
      species = species,
      vital_rate = vital_rate,
      N_size = N_size,
      intercept = NA,
      se.intercept = NA,
      treat_combi = c("bare.ambi", "bare.warm", "vege.ambi", "vege.warm"),
      stringsAsFactors = FALSE
    ))
  }
  
  # step 4: extract intercepts via emmeans --> extract which coefficients are used in this best_model
  
  # if the best model is NULL (shouldn't be the case)...
  if (is.null(best_model)) {
    vr_long_sid <- rbind(vr_long_sid, temp_results) # ...append results data frame with NA-filled rows
    next
  }
  
  # if the best model isn't NULL...
  # ...get population-level predictions for mixed models
  re_form_arg <- if (inherits(best_model, "merMod")) NA else NULL # what randpm structure has the best model? NA = marginal over REs; NULL = ignored for GLM
  
  # which fixed terms are present?
  fixed_terms <- attr(terms(best_model), "term.labels")
  has_comp <- any(grepl("^treat_comp", fixed_terms)) # is competition in the model?
  has_warm <- any(grepl("^treat_warm", fixed_terms)) # is warming in the model?
  
  # emmeans specifications that match the fitted fixed effects
  specs <- if (has_comp && has_warm) {
    ~ treat_comp * treat_warm
  } else if (has_comp) {
    ~ treat_comp
  } else if (has_warm) {
    ~ treat_warm
  } else {
    ~ 1
  }
  
  # step 5: calculate intercepts via emmeans (on link scale)
  emm_df <- as.data.frame(
    emmeans::emmeans(
      best_model, specs,
      # no size covariate here -> no 'at =' needed
      re.form = re_form_arg,  # NULL for GLM; NA for GLMM/LMM (marginal)
      type = "link"
    )
  )
  if (!("treat_comp" %in% names(emm_df))) emm_df$treat_comp <- NA # set treat_comp to NA if not in best_model
  if (!("treat_warm" %in% names(emm_df))) emm_df$treat_warm <- NA # set treat_warm to NA if not in best_model
  
  # function: helper to pick the right row for a treatment combination from the emmeans results table
  pick_row <- function(df, comp_lvl, warm_lvl, use_comp, use_warm) {
    dd <- df
    if (use_comp) dd <- dd[dd$treat_comp == comp_lvl, , drop = FALSE]
    if (use_warm) dd <- dd[dd$treat_warm == warm_lvl, , drop = FALSE]
    if (nrow(dd) == 0) dd <- df[1, , drop = FALSE] # fallback if filtering didn't work
    dd
  }
  
  # step 6: loop through each row in temp_results to extract and fill in correct intercepts
  for (j in 1:nrow(temp_results)) {
    current_treatcomp <- substr(temp_results$treat_combi[j], 1, 4)   # "bare"/"vege"
    current_treatwarm <- substr(temp_results$treat_combi[j], 6, 9)   # "ambi"/"warm"
    
    # intercept + SE (on link scale)
    dd_int <- pick_row(emm_df, current_treatcomp, current_treatwarm, has_comp, has_warm)
    temp_results$intercept[j]    <- dd_int$emmean
    temp_results$se.intercept[j] <- dd_int$SE
  }
  
  # step 7: add temporary results to the permanent dataframe
  vr_long_sid <- rbind(vr_long_sid, temp_results)
}

# add  best models back on to see whether all necessary coefficients were calculated
vr_long_sid_check <- vr_long_sid %>%
  left_join(final_summary_sid, by = c("vital_rate", "species", "site")) # looks good!

# Warning messages can be ignored: It's just emmeans saying that it ignores the per-row weights (successes + failures), which is alright, as the weights 
# are already used to fit the models. The warning is only issues for glms, not glmers as glmers are treated with a different method.


# ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
# VRF: BOOTSTRAPPING  ----
# ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

### bootstrapping --------------------------------------------------------------

#### size-dependent models -----------------------------------------------------

# initialize a data frame to store results
list_boot_sd <- list()
list_paraboot_sd <- list()

# start progress bar
pb <- txtProgressBar(min = 0, max = nrow(final_results_sd), style = 3)

# loop through each row of final_results_sd
for (i in seq_len(nrow(final_results_sd))) {
  
  # step 0: extract species, site and vital rate and determine whether it needs to be oversampled
  species  <- final_results_sd$species[i]
  site <- final_results_sd$site[i]
  vital_rate  <- final_results_sd$vital_rate[i]
  
  combo <- paste(vital_rate, site, species, sep = ".")
  
  nboot_i <- if (combo %in% c("flower_status.lo.scacol", "flower_status.lo.salpra", "survival.hi.brapin")) 6000 else 5000
  
  # step 1: extract the best model, its coefficients and data
  best_model <- final_results_sd$best_model[[i]]
  model_formula <- stats::formula(best_model)
  model_family <- stats::family(best_model) 
  response_variable <- as.character(model_formula[[2]])
  
  # extract the coefficients of the best model
  coefs <- if (inherits(best_model, c("glmerMod","lmerMod"))) lme4::fixef(best_model) else stats::coef(best_model)
  
  # get the data used to fit the model ready
  current_data <- final_results_sd$data[[i]] %>%
    suppressMessages(mutate(treat_comp = as.factor(treat_comp),
           treat_warm = as.factor(treat_warm)))
  
  # delete NAs in relevant columns
  if (grepl("seed", response_variable) == TRUE) {
    current_data <- suppressMessages(current_data %>%
      filter(!is.na(.data[[response_variable]]) & flower_status != 0)) # for seed models: also exclude individuals which don't flower
  } else {
    current_data <- suppressMessages(current_data %>%
      filter(!is.na(.data[[response_variable]])))
  }
  
  ## step 2: nonparametric bootstraping & storing results
  ## (add trycatch if there's contrast problems for one of the models - skip instead of stop)
  #boot_coefs <- tryCatch({
  #  bootstrap.npara(best_model, data = current_data)  
  #}, error = function(e) {
  #  cat("Error in model:", model_name, "\n")  # print the model info if there's problems
  #  cat("Error message:", conditionMessage(e), "\n")
  #  return(matrix(NA, nrow = 5000, ncol = length(coefs)))
  #})
  #
  ## add all the bootstrapped values to the boot_results data frame
  #colnames(boot_coefs) <- paste0(c(names(coefs), "sigma")) # all names of coefficients plus sigma (, ".int")
  #boot_coefs<- suppressMessages(as.data.frame(boot_coefs) %>%  
  #                                mutate(vital_rate = final_results_sd$vital_rate[i],
  #                                       species = final_results_sd$species[i],
  #                                       site = final_results_sd$site[i],
  #                                       bootstrap = row_number()))
  ## store results
  #list_boot_sd[[i]] <- boot_coefs
  
  # step 3: parametric bootstrapping & storing results
  paraboot_coefs <- tryCatch({
    bootstrap.para(model = best_model, data = current_data, nboot = nboot_i)
  }, error = function(e) {
    cat("Error in iteration:", i, "\n")
    cat("Error message:", conditionMessage(e), "\n")
    NULL
  })
  if (is.null(paraboot_coefs)) next
  
  paraboot_coefs <- suppressMessages(as.data.frame(paraboot_coefs) %>%
                                       dplyr::mutate(vital_rate = final_results_sd$vital_rate[i],
                                                     species    = final_results_sd$species[i],
                                                     site       = final_results_sd$site[i],
                                                     bootstrap  = dplyr::row_number()))
  
  # store parametric results
  list_paraboot_sd[[i]] <- paraboot_coefs
  
  # re-set best_model
  best_model <- NA
  current_data <- NA
  
  # update progress bar
  setTxtProgressBar(pb, i)
  
}

# close progress bar
close(pb)


# convert the list of results and bootstrapped coefficients to data frame and add models back on, plus delete sigma for all models except growth (can only be used for lm's not glm's)
pre_paraboot_sizedep <- bind_rows(list_paraboot_sd) %>%
  mutate(sigma = ifelse(vital_rate != "size_t1_log", NA, sigma))


#### recruit size -----------------------------------------------------


# empty list to store results for each species
list_nparaboot_recruit <- list()
list_paraboot_recruit <- list()

for (sp in unique(dat_seedl_ready2$species)) {
  # filter data for the specific species
  species_data <- dat_seedl_ready2 %>% filter(species == sp)
  
  # get bootstrapped results
  boot_results_para <- bootstrap.para.mean.sd(species_data$size_t0_log, nboot = 5000)
  
  # add species names
  boot_results_para$species <- sp
  boot_results_para <- boot_results_para %>% 
    mutate(bootstrap = row_number())
  
  # store results in list
  list_paraboot_recruit[[sp]] <- boot_results_para
}

# combine all results into a single data frame

pre_paraboot_recruit <- bind_rows(list_paraboot_recruit) %>%
  mutate(best_model_predictors = NA) %>%
  rename("r_mean" = "mean", "r_sd" = "sd")
pre_paraboot_recruit <- as.data.table(pre_paraboot_recruit)


#### size_independent models ---------------------------------------------------

# initialize a data frame to store results
list_boot_sid <- list()
list_paraboot_sid <- list()

# start progress bar
pb <- txtProgressBar(min = 0, max = nrow(final_results_sid), style = 3)


# loop through each row of final_results_sd
for (i in seq_len(nrow(final_results_sid))) {
  
  # step 1: extract the best model, its coefficients and data
  best_model <- final_results_sid$best_model[[i]]
  model_formula <- formula(best_model)
  model_family <- stats::family(best_model)
  #response_variable <- as.character(best_model$formula[[2]])
  vital_rate <- final_results_sid$vital_rate[[i]]
  
  # extract the coefficients of the best model & delete NAs in response column
  coefs <- if (inherits(best_model, "glmerMod")) lme4::fixef(best_model) else stats::coef(best_model)
  
  # define columns for success and failure and get data
  if (vital_rate == "germ_rate") {
    
    current_data <- suppressMessages(final_results_sid$data[[i]] %>%
                                       mutate(treat_comp = as.factor(treat_comp),
                                              treat_warm = as.factor(treat_warm),
                                              success = max_count,
                                              failure = mean_seedno - max_count) #%>%
                                       #filter(!is.na(.data[[response_variable]]))
                                     )

  } else if (vital_rate == "establishment") {
    
    current_data <- suppressMessages(final_results_sid$data[[i]] %>%
                                       mutate(treat_comp = as.factor(treat_comp),
                                              treat_warm = as.factor(treat_warm),
                                              success = peak_count,
                                              failure = max_count - peak_count) #%>%
                                       #filter(!is.na(.data[[response_variable]]))
                                     )
  }
  
  

  # step 2: bootstrap the model and store  results (add trycatch if tehre's contrast problems for one of the models - skip instead of stop)
  #boot_coefs <- tryCatch({
  #  bootstrap.npara(best_model, data = current_data)  
  #}, error = function(e) {
  #  cat("Error in model:", model_name, "\n")  # print the model info if there's problems
  #  cat("Error message:", conditionMessage(e), "\n")
  #  return(matrix(NA, nrow = 5000, ncol = length(coefs)))
  #})
  #
  ## add all the bootstrapped values to the boot_results data frame
  #colnames(boot_coefs) <- paste0(c(names(coefs), "sigma")) # all names of coefficients plus sigma (, ".int")
  #boot_coefs<- suppressMessages(as.data.frame(boot_coefs) %>%  
  #                                mutate(vital_rate = final_results_sid$vital_rate[i],
  #                                       species = final_results_sid$species[i],
  #                                       site = final_results_sid$site[i],
  #                                       bootstrap = row_number()))
  ## store results
  #list_boot_sid[[i]] <- boot_coefs
  
  # step 3: parametric bootstrapping & storing results
  paraboot_coefs <- tryCatch({
    bootstrap.para_matrix(model = best_model, data = current_data, nboot = 5000)
  }, error = function(e) {
    cat("Error in iteration:", i, "\n")
    cat("Error message:", conditionMessage(e), "\n")
    NULL
  })
  if (is.null(paraboot_coefs)) next
  
  paraboot_coefs <- suppressMessages(as.data.frame(paraboot_coefs) %>%
                                       dplyr::mutate(vital_rate = final_results_sid$vital_rate[i],
                                                     species    = final_results_sid$species[i],
                                                     site       = final_results_sid$site[i],
                                                     bootstrap  = dplyr::row_number()))
  # store results
  list_paraboot_sid[[i]] <- paraboot_coefs
  
  # re-set best_model
  best_model <- NA
  current_data <- NA
  
  
  # update progress bar
  setTxtProgressBar(pb, i)
}

# close progress bar
close(pb)


# convert the list of results and bootstrapped coefficients to data frame and add models back on, plus delete sigma for all models except growth (can only be used for lm's not glm's)
pre_paraboot_sizeind <- bind_rows(list_paraboot_sid) %>%
  mutate(sigma = ifelse(vital_rate != "size_t1_log", NA, sigma))


### extracting coefficients --------------------------------------------------------------

# all the coefficients and SDs of all the variables needed are ready, but for each lambda the coefficients should be assembled differently
# --> function for each vital rate which selects and extracts all wanted coefficients needed for a species and site

#### size-dependent models -----------------------------------------------------

# first add columns to boot indicating if and what interactions need to be considered

# get params ready: add model form, rename columns, get rid of superfluous columns
bootpara_sizedep_ready <- pre_paraboot_sizedep %>%
  left_join(final_results_sd[, c(2, 3, 10, 13, 17)], by = c("vital_rate", "site", "species")) %>% # vital_rate, site, species, best_model_predictors, N_size
  dplyr::select(-matches("upper|lower"), 
                -matches("sd")) %>%
  rename("Intercept" ="(Intercept)")

# check whether all columns are there
needed <- c("Intercept", "size_t0_log", "treat_compvege", "treat_warmwarm", "treat_compvege:treat_warmwarm", "size_t0_log:treat_compvege", 
            "size_t0_log:treat_warmwarm", "size_t0_log:treat_compvege:treat_warmwarm") # columns eeded for the extraction functions
all_coef_names <- unique(unlist(lapply(split(bootpara_sizedep_ready, seq_len(nrow(bootpara_sizedep_ready))),
                                               function(df) names(df)))) # columns in the bootstrap output

setdiff(needed, all_coef_names) # compare --> looks good

# calculate intercepts and slopes for all treatments and all models 
bootpara_intercepts_ready <- calculate.intercepts.parallel(bootpara_sizedep_ready) # WOW
bootpara_slopes_ready <- calculate.slopes.parallel(bootpara_sizedep_ready) # AMAZING


# add together
boot_columns_intercept <- c("vital_rate", "species", "site", "sigma", "best_model_predictors", "N_size", "intercept.bare.ambi", "intercept.bare.warm", "intercept.vege.ambi", "intercept.vege.warm", "bootstrap")
boot_columns_slope <- c("vital_rate", "species", "site", "sigma", "best_model_predictors", "N_size", "slope.bare.ambi", "slope.bare.warm", "slope.vege.ambi", "slope.vege.warm", "bootstrap")

bootpara_intercepts_ready <- as.data.table(bootpara_intercepts_ready)
bootpara_slopes_ready <- as.data.table(bootpara_slopes_ready)

bootpara_sizedep <- merge(bootpara_intercepts_ready[, ..boot_columns_intercept], 
                          bootpara_slopes_ready[, ..boot_columns_slope], 
                          by = c("vital_rate", "species", "site", "sigma", "best_model_predictors", "N_size", "bootstrap"), 
                          all = TRUE)

str(bootpara_sizedep)

# the functions to calculate the coefficients ignore whether it's hi or lo site and will therefore also calculate coefficients for impossible
# treatment combinations (warmed lo) - they will just not include and treat_warm coefficients as those won't be in the best models
# --> set those to NA retrospectively

bootpara_sizedep[site == "lo", `:=`(
  intercept.bare.warm = NA,
  intercept.vege.warm = NA,
  slope.bare.warm = NA,
  slope.vege.warm = NA)]


#### size-independent models ---------------------------------------------------

# get vr_sid and boot_sid ready: add model form, rename columns, get rid of superfluous columns
bootpara_sizeind_ready <- pre_paraboot_sizeind %>%
  left_join(final_results_sid[, c(1, 2, 10, 13, 17)], by = c("vital_rate", "site", "species")) %>% # vital_rate, site, species, best_model_predictors, N_size
  dplyr::select(-matches("upper|lower"), 
                -matches("sd")) %>%
  rename("Intercept" ="(Intercept)")


# calculate intercepts and slopes for all treatments and all models (there's no slopes!)

bootpara_sizeind <- calculate.intercepts.parallel(bootpara_sizeind_ready) # WITH WARM TREATMENT AND PARALLEL

# delete columns not needed
boot_columns_intercept <- c("vital_rate", "species", "site", "best_model_predictors", "N_size", "intercept.bare.ambi", "intercept.bare.warm", "intercept.vege.ambi", "intercept.vege.warm", "bootstrap")
bootpara_sizeind <- as.data.table(bootpara_sizeind)
bootpara_sizeind <- bootpara_sizeind[, ..boot_columns_intercept]


# ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
# VRF: DATA FRAME PREPARATION IPMS  ----
# ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

### preparation data frame -----------------------------------------------------

# work with data.table from now on
vr_long_sd <- as.data.table(vr_long_sd)
vr_long_sid <- as.data.table(vr_long_sid)
pre_vr_recruit <- as.data.table(pre_vr_recruit)

bootpara_sizedep <- as.data.table(bootpara_sizedep)
bootpara_sizeind <- as.data.table(bootpara_sizeind)
bootpara_recruit <- as.data.table(pre_paraboot_recruit)

# prepare a data frame with complete parameters for all treatments and vital rates

#### size-dependent models -----------------------------------------------------

# add empty columns for r_mean and r_sd
vr_long_sd[, `:=`(r_mean = NA, r_sd = NA)]

bootpara_sizedep[, `:=`(r_mean = NA, r_sd = NA)]

#### size-independent models ---------------------------------------------------

# check whether there are all necessary site * species * treatment combinations
vr_long_sid_sum <- vr_long_sid[, .(count = .N), by = .(site, species, vital_rate)]
# hypper lo is missing for both germination and establishment

# problem hypper: there's no germ_rate & establishment for the lo site specifically (see above), so just use the one from the hi site

# copy the hi site values, change site to lo and filter for the two treatments actually present at lo site
vr_long_sid_hypper <- copy(vr_long_sid[species == "hypper"])[, site := "lo"][treat_combi %in% c("bare.ambi", "vege.ambi")]

bootpara_sizeind_hypper <- copy(bootpara_sizeind[species == "hypper"])[, site := "lo"]


# combine vr_long_sid with vr_long_sid_hypper and mutate accordingly, dito with boot
vr_long_sid <- rbind(vr_long_sid, vr_long_sid_hypper)

bootpara_sizeind <- rbind(bootpara_sizeind, bootpara_sizeind_hypper)[, `:=`(
  #intercept.bare.ambi = intercept.bare,
  #intercept.bare.warm = ifelse(site == "lo", NA, intercept.bare),
  #intercept.vege.ambi = intercept.vege,
  #intercept.vege.warm = ifelse(site == "lo", NA, intercept.vege),
  slope.bare.ambi = NA,
  slope.bare.warm = NA,
  slope.vege.ambi = NA,
  slope.vege.warm = NA,
  sigma = NA
)]#[, c("Intercept", "treat_compvege", "intercept.bare", "intercept.vege") := NULL]

# add empty columns for r_mean and r_sd
vr_long_sid[, `:=`(r_mean = NA, r_sd = NA, slope = NA, se.slope = NA, sigma = NA)]

bootpara_sizeind[, `:=`(r_mean = NA, r_sd = NA)]

#### recruit size --------------------------------------------------------------

# get vr_recruit and boot_recruit ready

# duplicate boot_recruit to add values for site lo (are identical)
bootpara_recruit_hi <- copy(bootpara_recruit)[, site := "hi"]

# combine boot_recruit with boot_recruit_hi and mutate accordingly
bootpara_recruit <- rbind(copy(bootpara_recruit)[, site := "lo"], bootpara_recruit_hi)[, `:=`(
  intercept.bare.ambi = NA,
  intercept.bare.warm = NA,
  intercept.vege.ambi = NA,
  intercept.vege.warm = NA,
  slope.bare.ambi = NA,
  slope.bare.warm = NA,
  slope.vege.ambi = NA,
  slope.vege.warm = NA,
  sigma = NA,
  vital_rate = "recruit_size")]

# duplicate vr_recruit to add values for site lo, add on treatment combis
vr_recruit_hi <- copy(pre_vr_recruit)[, site := "hi"]
vr_recruit_lo <- copy(pre_vr_recruit)[, site := "lo"]

treatment_combinations <- list( # treatment combis
  copy(vr_recruit_lo)[, treat_combi := "bare.ambi"],
  copy(vr_recruit_lo)[, treat_combi := "vege.ambi"],
  copy(vr_recruit_hi)[, treat_combi := "bare.warm"],
  copy(vr_recruit_hi)[, treat_combi := "vege.warm"],
  copy(vr_recruit_hi)[, treat_combi := "bare.ambi"],
  copy(vr_recruit_hi)[, treat_combi := "vege.ambi"]
)

vr_long_recruit <- rbindlist(treatment_combinations)
vr_long_recruit[, `:=`(vital_rate = "recruit_size", slope = NA, se.slope = NA, sigma = NA, intercept = NA, 
                       se.intercept = NA)]
 
### combine --------------------------------------------------------------------

# combine the vr data.tables of all vital rates
vr_long <- rbind(vr_long_sd, vr_long_sid, vr_long_recruit) # should have a length of: 7 vital rates * 60 species/site/treatment combinations = 420 rows

# now combine all the boot data.tables and make them long
bootpara <- rbind(bootpara_sizedep, bootpara_sizeind, bootpara_recruit) 

# make long bootpara
bootpara_long_intercept <- melt(bootpara, measure.vars = patterns("^intercept."), # melt intercepts 
                            variable.name = "treat_combi",
                            value.name = "intercept")
bootpara_long_intercept[, treat_combi := gsub("intercept.", "", treat_combi)] # remove ".intercept"
bootpara_long <- melt(bootpara_long_intercept, measure.vars = patterns("^slope."), # melt slopes 
                  variable.name = "treat_combi_slope",
                  value.name = "slope")
bootpara_long[, treat_combi_slope := gsub("slope.", "", treat_combi_slope)] # remove ".slope"
bootpara_long <- bootpara_long[treat_combi == treat_combi_slope] # filter out rows where treat_combi does not match treat_combi_slope 
bootpara_long[, treat_combi_slope := NULL] #remove redundant column

# drop impossible warm-at-low across all vital rates
bootpara_long <- bootpara_long[!(site == "lo" & grepl("warm", treat_combi))]

# drop "all NA" rows except for recruit_size (where NA slope/intercept can be expected)
# first check out the fail rates of bootstraps
fail_rates <- bootpara_long %>%
  group_by(species, site, vital_rate, treat_combi) %>%
  summarise(fail_frac = mean(is.na(intercept) & is.na(slope) & vital_rate != "recruit_size"),
            .groups = "drop") # max. rate is 0.0462, which is very few --> can be ignored (even lower if for those three cases nboot is raised to 6000 instead of 5000)

# drop NA rows
bootpara_long <- bootpara_long[!(is.na(intercept) & is.na(slope) & vital_rate != "recruit_size")]

# cut off after 5000 bootstraps (this will be 1-5000 for combinations with no failures, and a few higher bootstrap Ids for the rest)
# generate a grouping key
bootpara_long[, combo := paste(vital_rate, site, species, sep = ".")]

# compute first 5000 successful bootstrap IDs per group
keep_ids_all <- bootpara_long[, {
  ids <- sort(unique(bootstrap))
  .(bootstrap = head(ids, 5000L))
}, by = .(vital_rate, site, species)]

# filter: keep only those replicates
bootpara_long <- bootpara_long[
  keep_ids_all, 
  on = .(vital_rate, site, species, bootstrap), 
  nomatch = 0L
]

# renumber 1:5000 so the IDs align when making a wide data frame
bootpara_long[, bootstrap := seq_len(.N), by = .(site, species, treat_combi, vital_rate)]

bootpara_long[, combo := NULL] # delete key column

# required no. rows: 420 (see for vr above) * 5000 = 2100000 - correct!

# also add U and L on for both vr_long and boot
biomass_range_summary_dt <- as.data.table(biomass_range_summary)

# vr_long
vr_long <- merge(vr_long, biomass_range_summary_dt, by = c("site", "species", "treat_combi"), all.x = TRUE)
setnames(vr_long, old = c("max_biomass", "min_biomass"), new = c("U", "L"))

# boot_long
bootpara_long <- merge(bootpara_long, biomass_range_summary_dt, by = c("site", "species", "treat_combi"), all.x = TRUE)
setnames(bootpara_long, old = c("max_biomass", "min_biomass"), new = c("U", "L"))

# back-transform the two resulting data tables to data frames for easier handling
vr_long <- as.data.frame(vr_long)

bootpara_long <- as.data.frame(bootpara_long)

# save vr_long
write_csv(vr_long, "output/IPM_VRlong_mixed_20251027_census1.csv")
write_csv(bootpara_long, "output/IPM_BootparaLong_mixed_20251027_census1.csv")

#write_csv(vr_long, "output/IPM_VRlong_mixed_20250929_census2.csv")
#write_csv(bootpara_long, "output/IPM_BootparaLong_mixed_20250929_census2.csv")

### control plotting -----------------------------------------------------------

# make a summary data frame with mean and sd of bootstrapped coefficients
bootpara_summary <- bootpara_long %>%
  filter(vital_rate != "recruit_size") %>%
  group_by(site, treat_combi, species, vital_rate) %>%
  summarize(boot_mean_int = mean(intercept),
            boot_mean_slope = mean(slope),
            boot_sd_int = sd(intercept),
            boot_sd_slope = sd(slope))

# add on "real" coefficients
bootpara_summary <- vr_long %>%
  filter(vital_rate != "recruit_size") %>%
  left_join(bootpara_summary, by = c("site", "treat_combi", "species", "vital_rate")) %>%
  mutate(bias_int = boot_mean_int - intercept,
         bias_slope = boot_mean_slope - slope,
         sd_ratio_int = boot_sd_int / se.intercept,
         sd_ratio_slope = boot_sd_slope / se.slope)

# plot distribution of of bootstrapped vital rate coefficient as control
pdf("plots/CoefDistribution_final_20251027_census1.pdf", height = 6, width = 8)
#pdf("plots/CoefDistribution_final_20250929_census2.pdf", height = 6, width = 8)

ggplot(bootpara_long[bootpara_long$vital_rate == "survival",], aes(x = intercept, fill = treat_combi)) + # [bootpara_long$species == "hypper",]
  geom_density(alpha = 0.6) +
  #geom_vline(data = vr_long, aes(xintercept = intercept), linetype = "dashed", color = "red") +
  theme_minimal() +
  labs(title = "Bootstrapped Coefficient Distributions: Survival, intercept (salpra, plamed, hypper, cenjac on species level)", x = "Coefficient Value", y = "Density") +
  facet_wrap(site ~ species, scales = "free")  # the division problem for cenjac is gone, not for hypper though...
ggplot(bootpara_long[bootpara_long$vital_rate == "size_t1_log",], aes(x = intercept, fill = treat_combi)) + # [bootpara_long$species == "hypper",]
  geom_density(alpha = 0.6) +
  #geom_vline(data = vr_long, aes(xintercept = intercept), linetype = "dashed", color = "red") +
  theme_minimal() +
  labs(title = "Bootstrapped Coefficient Distributions: Growth, intercept", x = "Coefficient Value", y = "Density") +
  facet_wrap(site ~ species, scales = "free") 
ggplot(bootpara_long[bootpara_long$vital_rate == "flower_status",], aes(x = intercept, fill = treat_combi)) + # [bootpara_long$species == "hypper",]
  geom_density(alpha = 0.6) +
  #geom_vline(data = vr_long, aes(xintercept = intercept), linetype = "dashed", color = "red") +
  theme_minimal() +
  labs(title = "Bootstrapped Coefficient Distributions: Flowering, intercept", x = "Coefficient Value", y = "Density") +
  facet_wrap(site ~ species, scales = "free") 
ggplot(bootpara_long[bootpara_long$vital_rate == "number_seeds",], aes(x = intercept, fill = treat_combi)) + # [bootpara_long$species == "hypper",]
  geom_density(alpha = 0.6) +
  #geom_vline(data = vr_long, aes(xintercept = intercept), linetype = "dashed", color = "red") +
  theme_minimal() +
  labs(title = "Bootstrapped Coefficient Distributions: Seeds, intercept", x = "Coefficient Value", y = "Density") +
  facet_wrap(site ~ species, scales = "free") 
ggplot(bootpara_long[bootpara_long$vital_rate == "germ_rate",], aes(x = intercept, fill = treat_combi)) + # [bootpara_long$species == "hypper",]
  geom_density(alpha = 0.6) +
  #geom_vline(data = vr_long, aes(xintercept = intercept), linetype = "dashed", color = "red") +
  theme_minimal() +
  labs(title = "Bootstrapped Coefficient Distributions: Germination, intercept", x = "Coefficient Value", y = "Density") +
  facet_wrap(site ~ species, scales = "free") 
ggplot(bootpara_long[bootpara_long$vital_rate == "establishment",], aes(x = intercept, fill = treat_combi)) + # [bootpara_long$species == "hypper",]
  geom_density(alpha = 0.6) +
  #geom_vline(data = vr_long, aes(xintercept = intercept), linetype = "dashed", color = "red") +
  theme_minimal() +
  labs(title = "Bootstrapped Coefficient Distributions: Establishment, intercept", x = "Coefficient Value", y = "Density") +
  facet_wrap(site ~ species, scales = "free") 

ggplot(bootpara_long[bootpara_long$vital_rate == "survival",], aes(x = slope, fill = treat_combi)) + # [bootpara_long$species == "hypper",]
  geom_density(alpha = 0.6) +
  #geom_vline(data = vr_long, aes(xslope = slope), linetype = "dashed", color = "red") +
  theme_minimal() +
  labs(title = "Bootstrapped Coefficient Distributions: Survival, slope", x = "Coefficient Value", y = "Density") +
  facet_wrap(site ~ species, scales = "free") # looks better?
ggplot(bootpara_long[bootpara_long$vital_rate == "size_t1_log",], aes(x = slope, fill = treat_combi)) + # [bootpara_long$species == "hypper",]
  geom_density(alpha = 0.6) +
  #geom_vline(data = vr_long, aes(xslope = slope), linetype = "dashed", color = "red") +
  theme_minimal() +
  labs(title = "Bootstrapped Coefficient Distributions: Growth, slope", x = "Coefficient Value", y = "Density") +
  facet_wrap(site ~ species, scales = "free") 
ggplot(bootpara_long[bootpara_long$vital_rate == "flower_status",], aes(x = slope, fill = treat_combi)) + # [bootpara_long$species == "hypper",]
  geom_density(alpha = 0.6) +
  #geom_vline(data = vr_long, aes(xslope = slope), linetype = "dashed", color = "red") +
  theme_minimal() +
  labs(title = "Bootstrapped Coefficient Distributions: Flowering, slope", x = "Coefficient Value", y = "Density") +
  facet_wrap(site ~ species, scales = "free") 
ggplot(bootpara_long[bootpara_long$vital_rate == "number_seeds",], aes(x = slope, fill = treat_combi)) + # [bootpara_long$species == "hypper",]
  geom_density(alpha = 0.6) +
  #geom_vline(data = vr_long, aes(xslope = slope), linetype = "dashed", color = "red") +
  theme_minimal() +
  labs(title = "Bootstrapped Coefficient Distributions: Seeds, slope", x = "Coefficient Value", y = "Density") +
  facet_wrap(site ~ species, scales = "free")

dev.off()

# ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
# VRF: VITAL RATES VS. RAW DATA  ----
# ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

### size-dependent models ------------------------------------------------------

# apply all vital rate functions to the original (but log-transformed) biomass data to compare vital rate predictions with raw data

# apply survival function for survival
pred_surv <- dat_YS_ready %>%
  mutate(treat_combi = paste(treat_comp, treat_warm, sep = "."),
         site_treat_combi = paste(site, treat_combi, sep = "_")) %>%
  left_join(vr_long[vr_long$vital_rate == "survival",], by = c("species", "site", "treat_combi", "treat_warm", "treat_comp")) %>%
  rename("surv.int" = "intercept", "surv.slope" = "slope") %>%
  rowwise() %>%
  mutate(surv.prob = survival.t0(size_t0_log, pick(surv.int, surv.slope))) %>% # 
  ungroup()

# growth (no ceiling)
pred_growth <- dat_YS_ready_small %>%
  mutate(treat_combi = paste(treat_comp, treat_warm, sep = "."),
         site_treat_combi = paste(site, treat_combi, sep = "_")) %>%
  left_join(vr_long[vr_long$vital_rate == "size_t1_log",], by = c("species", "site", "treat_combi", "treat_warm", "treat_comp")) %>%
  rename("growth.int" = "intercept", "growth.slope" = "slope", "growth.sigma" = "sigma") %>%
  rowwise() %>%
  mutate(growth.prob = growth.t0t(size_t1_log, size_t0_log, pick(growth.int, growth.slope, growth.sigma)),
         size_t1_log_pred = growth.t0(size_t0_log, pick(growth.int, growth.slope))) %>% # 
  ungroup()

# flowering
pred_flower <- dat_YS_ready %>%
  mutate(treat_combi = paste(treat_comp, treat_warm, sep = "."),
         site_treat_combi = paste(site, treat_combi, sep = "_")) %>%
  left_join(vr_long[vr_long$vital_rate == "flower_status",], by = c("species", "site", "treat_combi", "treat_warm", "treat_comp")) %>%
  rename("flow.int" = "intercept", "flow.slope" = "slope") %>%
  rowwise() %>%
  mutate(flower.prob = flowering.t0(size_t0_log, pick(flow.int, flow.slope))) %>% # 
  ungroup()

# seed production
pred_seed <- dat_YS_ready %>%
  mutate(treat_combi = paste(treat_comp, treat_warm, sep = "."),
         site_treat_combi = paste(site, treat_combi, sep = "_")) %>%
  left_join(vr_long[vr_long$vital_rate == "number_seeds",], by = c("species", "site", "treat_combi", "treat_warm", "treat_comp")) %>%
  rename("seed.int" = "intercept", "seed.slope" = "slope") %>%
  rowwise() %>%
  mutate(seed.no = seeds.t0_mean(size_t0_log, pick(seed.int, seed.slope))) %>% # 
  ungroup()


### recruit size ---------------------------------------------------------------

# recruit size
pred_recruit <- dat_seedl_ready %>%
  filter(!is.na(size_t0_log)) %>% 
  left_join(vr_long[vr_long$vital_rate == "recruit_size",], by = c("species")) %>%
  rowwise() %>%
  mutate(rpd = seedling.t(size_t0_log, pick(r_mean, r_sd)),
         site_treat_combi = paste(site, treat_combi, sep = "_")) %>% # rpd = recruit probability density
  ungroup()



### size-independent models ----------------------------------------------------

# germination
pred_germ <- dat_germ_ready %>%
  mutate(treat_combi = paste(treat_comp, treat_warm, sep = "."),,
         site_treat_combi = paste(site, treat_combi, sep = "_")) %>%
  left_join(vr_long[vr_long$vital_rate == "germ_rate",], by = c("species", "site", "treat_combi", "treat_warm", "treat_comp")) %>%
  rename("germ.int" = "intercept") %>%
  rowwise() %>%
  mutate(germ.prob = germination(pick(germ.int))) %>% # 
  ungroup() # the 688 NA warnings are alright: it's either non-flowering individuals (mostly) or individuals where size_t0_log is in best model but size_t0 was not recorded

# the 2 rows only in vr_long are hypper lo bare and vege: there's no raw data for this combination, but for vr_long it just uses the coefficients from the high site -->
vr_long[vr_long$species == "hypper" & vr_long$vital_rate == "germ_rate",]

# establishment
pred_est <- dat_germ_ready %>%
  mutate(treat_combi = paste(treat_comp, treat_warm, sep = "."),
         site_treat_combi = paste(site, treat_combi, sep = "_"),
         establishment_plot = peak_count/max_count) %>% # calculate an establishment rate out of how many seedlings stayed alive from all germinated seedlings
  left_join(vr_long[vr_long$vital_rate == "establishment",], by = c("species", "site", "treat_combi", "treat_warm", "treat_comp")) %>%
  rename("est.int" = "intercept") %>%
  rowwise() %>%
  mutate(est.prob = establishment(pick(est.int))) %>% 
  ungroup()
  
  

### plotting -------------------------------------------------------------------

### SIZE DEPENDENT

# survival 
png("plots/FigVR_surv_nolegend_20251027.png", width = 24, height = 10, units="cm", res=800)

ggplot(data = pred_surv[is.na(pred_surv$survival) == FALSE,], aes(x = size_t0_log, y = as.numeric(as.character(survival)))) +
  geom_jitter(col = "gray", position = position_jitter(height = 0.05)) +
  geom_line(aes(x = size_t0_log, y = surv.prob, col = site_treat_combi), size = 1.5, alpha = 0.8) +
  facet_grid(site ~ species, scales = "free", labeller = labeller(site = site_labs, species = species_labs)) +
  theme_bw() +
  theme(strip.background = element_blank(),
        axis.text.x = element_text(angle = 90), 
        axis.title = element_text(face = "bold", size = 12)) +
  labs(x = "Survival", y = "log(Size at t0)") +
  scale_color_manual(name = "Treatment Combination", 
                     values = treat_combi_site_col, 
                     labels = treat_combi_labs) +
  guides(colour = FALSE) +
  labs(tag = "a") +
  theme(plot.tag.position = c(0.015, 0.97),
        plot.tag = element_text(face = "bold", size = 24))

dev.off()

# legend
surv_with_legend <- ggplot(data = pred_surv[is.na(pred_surv$survival) == FALSE,], aes(x = size_t0_log, y = as.numeric(as.character(survival)))) +
  geom_jitter(col = "gray", position = position_jitter(height = 0.05)) +
  geom_line(aes(x = size_t0_log, y = surv.prob, col = site_treat_combi), size = 1.5, alpha = 0.8) +
  facet_grid(site ~ species, scales = "free", labeller = labeller(site = site_labs, species = species_labs)) +
  theme_bw() +
  theme(strip.background = element_blank(),
        axis.text.x = element_text(angle = 90), 
        axis.title = element_text(face = "bold", size = 12),
        legend.position = "top") +
  labs(x = "Survival", y = "log(Size at t0)") +
  scale_color_manual(name = "Treatment Combination", 
                     values = treat_combi_site_col, 
                     labels = treat_combi_labs) +
  guides(colour = guide_legend(title = "Treatment Combination", title.position = "top"))

legend <- g_legend(surv_with_legend)
grid.draw(legend)

ggsave("plots/FigVR_legend_20251027.png", legend, width = 7.2, height = 1, dpi = 300)
  
# growth
png("plots/FigVR_grow_nolegend_20251027_census1.png", width = 24, height = 10, units="cm", res=800)
#png("plots/FigVR_grow_nolegend_20250929_census2.png", width = 24, height = 10, units="cm", res=800)

ggplot(data = pred_growth[is.na(pred_growth$size_t1_log) == FALSE,], aes(x = size_t0_log, y = size_t1_log)) +
  geom_point(col = "gray") +
  geom_line(aes(x = size_t0_log, y = size_t1_log_pred, col = site_treat_combi), size = 1.5, alpha = 0.8) +
  facet_grid(site ~ species, scales = "free", labeller = labeller(site = site_labs, species = species_labs)) +
  theme_bw() +
  theme(strip.background = element_blank(),
        axis.text.x = element_text(angle = 90), 
        axis.title = element_text(face = "bold", size = 12)) +
  labs(x = "log(Size at t1)", y = "log(Size at t0)") +  
  scale_color_manual(name = "Treatment Combination", 
                     values = treat_combi_site_col, 
                     labels = treat_combi_labs) +
  guides(colour = FALSE) +
  labs(tag = "b") +
  theme(plot.tag.position = c(0.015, 0.97),
        plot.tag = element_text(face = "bold", size = 24))

dev.off()

# flowering
png("plots/FigVR_flow_nolegend_20251027.png", width = 24, height = 10, units="cm", res=800)

ggplot(data = pred_flower[is.na(pred_flower$flower_status) == FALSE,], aes(x = size_t0_log, y = as.numeric(as.character(flower_status)))) +
  geom_point(col = "gray", position = position_jitter(height = 0.05)) +
  geom_line(aes(x = size_t0_log, y = flower.prob, col = site_treat_combi), size = 1.5, alpha = 0.8) +
  facet_grid(site ~ species, scales = "free", labeller = labeller(site = site_labs, species = species_labs)) +
  theme_bw() +
  theme(strip.background = element_blank(),
        axis.text.x = element_text(angle = 90), 
        axis.title = element_text(face = "bold", size = 12)) +
  labs(x = "log(Size at t1)", y = "Flowering") +  
  scale_color_manual(name = "Treatment Combination", 
                     values = treat_combi_site_col, 
                     labels = treat_combi_labs) +
  guides(colour = FALSE) +
  labs(tag = "c") +
  theme(plot.tag.position = c(0.015, 0.97),
        plot.tag = element_text(face = "bold", size = 24))

dev.off()

# seed production
png("plots/FigVR_seed_nolegend_20251027.png", width = 24, height = 10, units="cm", res=800)

ggplot(data = pred_seed[is.na(pred_seed$number_seeds) == FALSE,], aes(x = size_t0_log, y = log(number_seeds))) +
  geom_point(col = "gray") +
  geom_line(aes(x = size_t0_log, y = log(seed.no), col = site_treat_combi), size = 1.5, alpha = 0.8) +
  facet_grid(site ~ species, scales = "free", labeller = labeller(site = site_labs, species = species_labs)) +
  theme_bw() +
  theme(strip.background = element_blank(),
        axis.text.x = element_text(angle = 90), 
        axis.title = element_text(face = "bold", size = 12)) +
  labs(x = "log(Size at t1)", y = "log(Number of seeds)") +  
  scale_color_manual(name = "Treatment Combination", 
                     values = treat_combi_site_col, 
                     labels = treat_combi_labs) +
  guides(colour = FALSE) +
  labs(tag = "d") +
  theme(plot.tag.position = c(0.015, 0.97),
        plot.tag = element_text(face = "bold", size = 24))

dev.off()

### SIZE INDEPENDENT

# germination rate
png("plots/FigVR_germ_nolegend_20251027.png", width = 24, height = 10, units="cm", res=800)

ggplot(data = pred_germ[is.na(pred_germ$germ_rate) == FALSE,], aes(x = treat_combi, y = germ_rate, group = treat_combi)) +
  geom_point(col = "gray") +
  geom_point(aes(x = treat_combi, y = germ.prob, col = site_treat_combi), size = 3) +
  facet_grid(site ~ species, scales = "free", labeller = labeller(site = site_labs, species = species_labs)) +
  theme_bw() +
  theme(strip.background = element_blank(),
        axis.text.x = element_blank(), 
        axis.title = element_text(face = "bold", size = 12)) +
  labs(x = "Treatment", y = "Germination rate") +  
  scale_color_manual(name = "Treatment Combination", 
                     values = treat_combi_site_col, 
                     labels = treat_combi_labs) +
  guides(colour = FALSE) +
  labs(tag = "e") +
  theme(plot.tag.position = c(0.015, 0.97),
        plot.tag = element_text(face = "bold", size = 24))

dev.off()

# establishment rate
png("plots/FigVR_etsb_nolegend_20251027.png", width = 24, height = 10, units="cm", res=800)

ggplot(data = pred_est[is.na(pred_est$establishment) == FALSE,], aes(x = treat_combi, y = establishment_plot)) +
  geom_point(col = "gray", position = position_jitter(height = 0.01)) +
  geom_point(aes(x = treat_combi, y = est.prob, col = site_treat_combi), size = 3) +
  facet_grid(site ~ species, scales = "free", labeller = labeller(site = site_labs, species = species_labs)) +
  theme_bw() +
  theme(strip.background = element_blank(),
        axis.text.x = element_blank(), 
        axis.title = element_text(face = "bold", size = 12)) +
  labs(x = "Treatment", y = "Establishment rate") +  
  scale_color_manual(name = "Treatment Combination", 
                     values = treat_combi_site_col, 
                     labels = treat_combi_labs) +
  guides(colour = FALSE) +
  labs(tag = "f") +
  theme(plot.tag.position = c(0.015, 0.97),
        plot.tag = element_text(face = "bold", size = 24))

dev.off()


# RECRUIT SIZE DISTRIBUTION

# recruit size distribution
png("plots/FigVR_rcsz_nolegend_20251027.png", width = 24, height = 5, units="cm", res=800)

ggplot(data = pred_recruit, aes(x = size_t0_log)) +
  geom_histogram(aes(y = ..density..), bins = 20, fill = "gray", alpha = 0.5) +
  geom_point(aes(y = rpd), size = 1.5, color = "black") +
  facet_wrap( ~ species, scales = "free", labeller = labeller(site = site_labs, species = species_labs), nrow = 1) +
  theme_bw() +
  theme(strip.background = element_blank(),
        axis.text.x = element_text(angle = 90), 
        axis.title = element_text(face = "bold", size = 12)) +
  labs(x = "log(Size at t0)", y = "Density") +  
  scale_color_manual(name = "Treatment Combination", 
                     values = treat_combi_site_col, 
                     labels = treat_combi_labs) +
  guides(colour = FALSE) +
  labs(tag = "g") +
  theme(plot.tag.position = c(0.015, 0.97),
        plot.tag = element_text(face = "bold", size = 24))

dev.off()



# ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
# FIT IPM  ----
# ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


# fit ipms for all combinations

# unique combinations of species, site, and treatment
sst_combinations <- vr_long %>%
  distinct(species, site, treat_combi)

# transform the vital rate coefficients into a list 
params_list <- mk.params.list(data_vrcols = vr_long, data_sstcombi = sst_combinations)


# generate the kernels and plot
# list to store kernel results
ipm.allcombis <- list()

# create a progress bar for kernel generation
pb2 <- progress_estimated(length(params_list))

# loop through the list of parameters to calculate IPM kernels and plot
for (name in names(params_list)) {
  
  # start the progress bar
  pb2$tick()$print()
  
  # retrieve the current parameters, L and U from the list
  current_params <- params_list[[name]]
  L_current <- params_list[[name]]$L
  U_current <- params_list[[name]]$U
  
  # fit the kernel using the parameters
  ipm_kernel <- mk.kernel(n = 500, L = L_current, U = U_current, par = current_params, ceiling_growth = FALSE, ceiling_seeds = FALSE) # USING seed-t0_mean!!
  
  # store the kernel and mesh points in the ipm.allcombis list
  ipm.allcombis[[name]] <- list(
    K = ipm_kernel$K,
    G = ipm_kernel$G,
    R = ipm_kernel$R,
    meshpts = exp(ipm_kernel$meshpts),
    L = L_current,
    U = U_current
  )
  
  # extract species, site, and treat_combi from the name
  combi_parts <- strsplit(name, "_")[[1]]
  species <- combi_parts[1]
  site <- combi_parts[2]
  treat_combi <- combi_parts[3]
  
  ## plot the kernel and save it
  #png(filename = file.path("/yourpath/plots/", paste("IPM_Kernel_", species, site, treat_combi, ".png", sep = "")),
  #    width = 800, height = 600)
  
  #plot.kernel(ipm.allcombis[[name]]$meshpts, 
  #            ipm.allcombis[[name]]$meshpts, 
  #            ipm.allcombis[[name]]$K, 
  #            xlab = "Size at t0", 
  #            ylab = "Size at t", 
  #            main = paste("IPM Kernel for", species, site, treat_combi))
  #
  #dev.off()
}


# ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
# POPULATION GROWTH RATE  ----
# ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

### calculate lambda -----------------------------------------------------------

# calculate lambda for all species*treatment*site combinations

lambda_results <- lapply(names(ipm.allcombis), function(name) {
  lambda.iter(k = ipm.allcombis[[name]]$K)  # apply lambda.iter to each K matrix while using the names of the elements for clarity
})


# name the output list
names(lambda_results) <- names(ipm.allcombis)

# create a data frame for plotting
lambda_values <- sapply(lambda_results, function(x) x$lambda)

names_list <- names(lambda_results)

lambda.allcombis <- data.frame(spsi_treatcombi = names_list, lambda = lambda_values, stringsAsFactors = FALSE, row.names = NULL) %>%
  mutate(species = str_sub(spsi_treatcombi, 1, 6),
         site = str_sub(spsi_treatcombi, 8, 9),
         treat_combi = str_sub(spsi_treatcombi, 11, 19),
         site_treat_combi = paste(site, treat_combi, sep = "."),
         treat_warm = str_sub(treat_combi, 6, 9),
         treat_comp = str_sub(treat_combi, 1, 4),
         trend = ifelse(lambda < 1, "shrink", "grow"),
         method = "normal")

# save lambdas as a data frame for paper
write.csv(lambda.allcombis, "data/derived/IPM_lambdas_20251027_census1.csv")
#write.csv(lambda.allcombis, "data/derived/IPM_lambdas_20250929_census2.csv")

lambda.allcombis_c1 <- read_csv("data/derived/IPM_lambdas_20251027_census1.csv") %>%
  dplyr::select(-1)
lambda.allcombis_c2 <- read.csv("data/derived/IPM_lambdas_20250929_census2.csv") %>%
  dplyr::select(-1)

### number of bins -------------------------------------------------------------

# determine the number of bins (i.e. minimal size of matrix so that lambda still converges)

# do for all
bins_convergence <- lapply(names(params_list), function(param_name) {
  # extract parameters
  params <- params_list[[param_name]]
  
  # run number.bins
  result <- number.bins(params = params, start = 100, end = 3000, step.n = 100, tol = 1e-8)

  return(list(param_name = param_name, result = result))
})


# extract the matrix size where it converged
dat_bins_convergence <- do.call(rbind, lapply(bins_convergence, function(x) {
  data.frame(param_name = x$param_name, n.converged = x$result$n.converged)
}))

# min. 200, max. 2500 (2022-2023 growth data)
# min. 200, max. 2700, 3 failed to converge (2021-2022 growth data)

# As long as lambda is not changing too much when using 500 vs. 3000 bins, it is ok to use the lower number. Therefore:
# 1) For each (species × site × treatment), compute the difference in lambda for the “true” fits (i.e. not bootstrapped, Δ_mesh = |λ_3000 - λ_500|.
# 2) If Δ_mesh ≤ 0.01, accept n = 500 for that combo.
# 3) If Δ_mesh > 0.01, quantify bootstrap uncertainty at n = 500:
#    - compute the 95% CI half-width h = (q97.5 - q2.5)/2 from the bootstrap λ’s.
#    - accept n = 500 if Δ_mesh ≤ max(0.005, 0.10 * h)  (i.e., mesh error should be ≤10% of lambda uncertainty (with a 0.005 floor to avoid flagging tiny differences in lambdas with very low uncertainty).
# 4) Otherwise, increase n only for those failing combos (e.g., 1500–2500) and/or widen L/U to reduce eviction; re-check until the criterion is met.

# check whether nbin = 500 is alright

# fit ipms for all combinations with n = 3000
ipm.allcombis3000 <- list()

pb2 <- progress_estimated(length(params_list))

# loop through the list of parameters to calculate IPM kernels and plot
for (name in names(params_list)) {
  
  # start the progress bar
  pb2$tick()$print()
  
  # retrieve the current parameters, L and U from the list
  current_params <- params_list[[name]]
  L_current <- params_list[[name]]$L
  U_current <- params_list[[name]]$U
  
  # fit the kernel using the parameters
  ipm_kernel3000 <- mk.kernel(n = 3000, L = L_current, U = U_current, par = current_params, ceiling_growth = FALSE, ceiling_seeds = FALSE) # USING seed-t0_mean!!
  
  # store the kernel and mesh points in the ipm.allcombis list
  ipm.allcombis3000[[name]] <- list(
    K = ipm_kernel3000$K,
    G = ipm_kernel3000$G,
    meshpts = exp(ipm_kernel3000$meshpts),
    L = L_current,
    U = U_current
  )
  
  # extract species, site, and treat_combi from the name
  combi_parts <- strsplit(name, "_")[[1]]
  species <- combi_parts[1]
  site <- combi_parts[2]
  treat_combi <- combi_parts[3]
}

# calculate lambdas with 3000 bins
lambda_results3000 <- lapply(names(ipm.allcombis3000), function(name) {
  lambda.iter(k = ipm.allcombis3000[[name]]$K)  # apply lambda.iter to each K matrix while using the names of the elements for clarity
})

names(lambda_results3000) <- names(ipm.allcombis3000) # name the output list
lambda_values3000 <- sapply(lambda_results3000, function(x) x$lambda) # create a data frame for plotting
names_list3000 <- names(lambda_results3000)

lambda.allcombis3000 <- data.frame(spsi_treatcombi = names_list, lambda = lambda_values3000, stringsAsFactors = FALSE, row.names = NULL) %>%
  mutate(species = str_sub(spsi_treatcombi, 1, 6),
         site = str_sub(spsi_treatcombi, 8, 9),
         treat_combi = str_sub(spsi_treatcombi, 11, 19),
         site_treat_combi = paste(site, treat_combi, sep = "."),
         treat_warm = str_sub(treat_combi, 6, 9),
         treat_comp = str_sub(treat_combi, 1, 4),
         ) %>%
  rename("lambda3000" = "lambda")

# calculate difference Δ_mesh = |λ_3000 - λ_500|
lambda_diff <- lambda.allcombis %>%
  left_join(lambda.allcombis3000, by = c("spsi_treatcombi", "species", "site", "treat_combi", "site_treat_combi", "treat_warm", "treat_comp")) %>%
  mutate(lambda_diff = abs(lambda3000 - lambda),
         mesh500ok = ifelse(lambda_diff <= 0.01, "ok", "not ok"))

# the difference between lambda with 3000 bins and lambda with 500 bins is max. 4.987276e-05, using 500 bins is therefore ok for all species * treatment * site combinations

### bootstrap lambda -----------------------------------------------------------

# make data.tables again
bootpara_long <- as.data.table(bootpara_long)

# generate a list containing different parameters for making full kernels
# make boot wide
bootpara_wide <- dcast(bootpara_long[vital_rate %in% c("recruit_size", "survival", "size_t1_log", "flower_status", "number_seeds", "germ_rate", "establishment")],
                        formula = site + species + treat_combi + bootstrap + L + U ~ vital_rate,
                        value.var = c("r_mean", "r_sd", "intercept", "slope", "sigma"),
                        fun.aggregate = mean)

# delete empty columns and rename
bootpara_wide <- bootpara_wide %>%
  rename("r_mean" = "r_mean_recruit_size", "r_sd" = "r_sd_recruit_size", "sigma" = "sigma_size_t1_log") %>%
  dplyr::select(c(1:6), r_mean, r_sd, sigma, slope_size_t1_log, slope_flower_status, slope_number_seeds, slope_survival, intercept_size_t1_log, intercept_establishment,
                intercept_flower_status, intercept_number_seeds, intercept_survival, intercept_germ_rate)

# save boot_wide as a data frame
write.csv(bootpara_wide, "data/derived/IPM_bootstrappedVR_para_cluster_c1.csv")
#write.csv(bootpara_wide, "data/derived/IPM_bootstrappedVR_para_cluster.csv")


### CLEAN SAVE UP TO CLUSTER CENSUS 1 **************************************----

#save.image(file = "/Users/eviseli/Desktop/SaveImageR/IPMs_20251027_census1.RData")
load(file = "/Users/eviseli/Desktop/SaveImageR/IPMs_20251027_census1.RData")

### ************************************************************************----

### CLEAN SAVE UP TO CLUSTER CENSUS 2 **************************************----

#save.image(file = "/Users/eviseli/Desktop/SaveImageR/IPMs_20250930_census2.RData")
#load(file = "/Users/eviseli/Desktop/SaveImageR/IPMs_20250930_census2.RData")

### ************************************************************************----



### cluster code ---------------------------------------------------------------

# The bootstrapped lambda calculations are done on the cluster. See file RangeX_IPMs_clustercode_20251027.R for code used.


#  load the calculated lambdas from cluster
lambda_popsize_bootpara_c1 <- read_csv("data/derived/IPM_bootstrappedLambda_para_cluster_c1.csv") %>% # census 1 cluster run
  dplyr::select(-sp_seed_to_sc1, -1) # delete typo column
lambda_popsize_bootpara_c2 <- read_csv("data/derived/IPM_bootstrappedLambda_para_cluster_c2.csv") %>% # census 2 cluster run
  dplyr::select(-sp_seed_to_sc1, -1)

# separate the name and extract lambda data
lambda_bootpara_c1 <- lambda_popsize_bootpara_c1 %>%
  dplyr::select(-required_sc1, -required_seeds, -gT, -p_seed_to_sc1,) %>%
  mutate(site = str_sub(parameter_name, 8, 9),
         species = str_sub(parameter_name, 1, 6),
         treat_combi = str_sub(parameter_name, 11, 19),
         treat_comp = str_sub(treat_combi, 1, 4),
         treat_warm = str_sub(treat_combi, 6, 9),
         bootstrap = str_sub(parameter_name, 21, nchar(parameter_name)),
         bootstrap = as.integer(str_extract(bootstrap, "\\d+")))
lambda_bootpara_c2 <- lambda_popsize_bootpara_c2 %>%
  dplyr::select(-required_sc1, -required_seeds, gT, p_seed_to_sc1) %>%
  mutate(site = str_sub(parameter_name, 8, 9),
         species = str_sub(parameter_name, 1, 6),
         treat_combi = str_sub(parameter_name, 11, 19),
         treat_comp = str_sub(treat_combi, 1, 4),
         treat_warm = str_sub(treat_combi, 6, 9),
         bootstrap = str_sub(parameter_name, 21, nchar(parameter_name)),
         bootstrap = as.integer(str_extract(bootstrap, "\\d+")))


### calculate CIs --------------------------------------------------------------

# check how much the bootstrapped lambdas are skewed for all species (species with slightly skewed lambdas: salpra vege, brapin vege, daucar bare ambi lo)
ggplot(data = lambda_bootpara_c1, aes(x = as.factor(treat_combi), y = as.numeric(lambda), fill = site)) +
  geom_violin() +
  facet_wrap(treat_combi ~ species, scales = "free")

# also check whether there are few extreme lambdas for some species (looks alright)
ggplot(data = lambda_bootpara_c1, aes(x = species, y = as.numeric(lambda), col = species)) +
  geom_point() +
  facet_grid(treat_combi ~ site, scales = "free") 

# calculate uncorrected confidence intervals
lambda.allcombis.bootpara_c1 <- lambda_bootpara_c1 %>%
  group_by(site, species, treat_combi, treat_warm, treat_comp) %>%
  summarize(boot_mean = mean(lambda),
            lower_CI = quantile(lambda, 0.025),
            upper_CI = quantile(lambda, 0.975)) %>%
  ungroup() %>%
  left_join(lambda.allcombis_c1, by = c("site", "species", "treat_combi", "treat_warm", "treat_comp"))
lambda.allcombis.bootpara_c2 <- lambda_bootpara_c2 %>%
  group_by(site, species, treat_combi, treat_warm, treat_comp) %>%
  summarize(boot_mean = mean(lambda),
            lower_CI = quantile(lambda, 0.025),
            upper_CI = quantile(lambda, 0.975)) %>%
  ungroup() %>%
  left_join(lambda.allcombis_c2, by = c("site", "species", "treat_combi", "treat_warm", "treat_comp"))


# calculate bias corrected confidence intervals of "real" lambdas
alpha <- 0.05

lambda.allcombis.bootpara.bcpi_c1 <- lambda_bootpara_c1 %>%
  group_by(species, site, treat_combi, treat_warm, treat_comp) %>%
  summarize(bootstrapped_values = list(lambda), .groups = 'drop') %>%
  ungroup() %>%
  left_join(lambda.allcombis_c1, by = c("species", "site", "treat_combi", "treat_comp", "treat_warm")) %>%
  mutate(bcpi_CI = map2(bootstrapped_values, lambda, ~ bcpi(.y, .x, alpha)),  # .y is real_lambda, .x is t (bootstrapped values)
         lower_BCPI = sapply(bcpi_CI, `[[`, 1),  
         upper_BCPI = sapply(bcpi_CI, `[[`, 2),
         mean_bootstrap = sapply(bootstrapped_values, mean)) %>%
  ungroup() %>%
  mutate(treat_warm = str_sub(treat_combi, 6, 9),
         treat_comp = str_sub(treat_combi, 1,4),
         treat_warm_site = paste(site, treat_warm, sep = "_"), 
         site_treat_combi = factor(paste(site, treat_combi, sep = "_"), levels = c("lo_bare.ambi", "lo_vege.ambi", "hi_bare.ambi", "hi_vege.ambi", "hi_bare.warm", "hi_vege.warm")),
         treat_comp_trend = paste(treat_comp, trend, sep = "_")) %>%
  ungroup()
lambda.allcombis.bootpara.bcpi_c2 <- lambda_bootpara_c2 %>%
  group_by(species, site, treat_combi, treat_warm, treat_comp) %>%
  summarize(bootstrapped_values = list(lambda), .groups = 'drop') %>%
  ungroup() %>%
  left_join(lambda.allcombis_c2, by = c("species", "site", "treat_combi", "treat_comp", "treat_warm")) %>%
  mutate(bcpi_CI = map2(bootstrapped_values, lambda, ~ bcpi(.y, .x, alpha)),  # .y is real_lambda, .x is t (bootstrapped values)
         lower_BCPI = sapply(bcpi_CI, `[[`, 1),  
         upper_BCPI = sapply(bcpi_CI, `[[`, 2),
         mean_bootstrap = sapply(bootstrapped_values, mean)) %>%
  ungroup() %>%
  mutate(treat_warm = str_sub(treat_combi, 6, 9),
         treat_comp = str_sub(treat_combi, 1,4),
         treat_warm_site = paste(site, treat_warm, sep = "_"), 
         site_treat_combi = factor(paste(site, treat_combi, sep = "_"), levels = c("lo_bare.ambi", "lo_vege.ambi", "hi_bare.ambi", "hi_vege.ambi", "hi_bare.warm", "hi_vege.warm")),
         treat_comp_trend = paste(treat_comp, trend, sep = "_")) %>%
  ungroup()

# get averages and SDs of PGR for the different treatments
mean(lambda.allcombis_c1[lambda.allcombis_c1$site == "hi" & lambda.allcombis_c1$treat_combi == "bare.ambi",]$lambda)
sd(lambda.allcombis_c1[lambda.allcombis_c1$site == "hi" & lambda.allcombis_c1$treat_combi == "bare.ambi",]$lambda)

mean(lambda.allcombis_c1[lambda.allcombis_c1$site == "hi" & lambda.allcombis_c1$treat_combi == "bare.warm",]$lambda)
sd(lambda.allcombis_c1[lambda.allcombis_c1$site == "hi" & lambda.allcombis_c1$treat_combi == "bare.warm",]$lambda)

mean(lambda.allcombis_c1[lambda.allcombis_c1$site == "lo" & lambda.allcombis_c1$treat_combi == "bare.ambi",]$lambda)
sd(lambda.allcombis_c1[lambda.allcombis_c1$site == "lo" & lambda.allcombis_c1$treat_combi == "bare.ambi",]$lambda)

mean(lambda.allcombis_c1[lambda.allcombis_c1$site == "hi" & lambda.allcombis_c1$treat_combi == "vege.ambi",]$lambda)
sd(lambda.allcombis_c1[lambda.allcombis_c1$site == "hi" & lambda.allcombis_c1$treat_combi == "vege.ambi",]$lambda)

mean(lambda.allcombis_c1[lambda.allcombis_c1$site == "hi" & lambda.allcombis_c1$treat_combi == "vege.warm",]$lambda)
sd(lambda.allcombis_c1[lambda.allcombis_c1$site == "hi" & lambda.allcombis_c1$treat_combi == "vege.warm",]$lambda)



### plotting -------------------------------------------------------------------

# plot lambdas separately for species

# plot lambdas with BCPI and add mean bootstrapped lambda as black dot
ggplot(data = lambda.allcombis.bootpara.bcpi_c1, aes(x = as.factor(site_treat_combi), y = lambda)) + # , col = site
  geom_point(aes(shape = trend), size = 4, col = "red") + 
  geom_point(aes(x = as.factor(site_treat_combi), y = mean_bootstrap), col = "black") +
  geom_errorbar(aes(ymin = lower_BCPI, ymax = upper_BCPI), width = 0.2) +
  facet_wrap(~species, scales = "free") + # , scales = "free"
  #ylim(0, 3) +
  geom_abline(intercept = 1, slope = 0) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 90)) +
  labs(x = "site - treatment combinations", y = "lambda") +
  ggtitle("Parametric bootstrapping (BCPI)") 


# bootstrap mean and "real" lambdas are quite similar

# prepare for plotting

# get decreasing lambdas for hi vege.ambi
a <- lambda.allcombis_c1 %>%
  filter(site == "hi" & treat_combi == "vege.ambi")

# re-order species for plotting
sp_order <- c("daucar", "medlup", "cenjac", "hypper", "plamed", "broere", "salpra", "brapin", "silvul",  "scacol")
lambda.allcombis.bootpara.bcpi_c1$species <- factor(lambda.allcombis.bootpara.bcpi_c1$species, levels = sp_order)
lambda.allcombis.bootpara_c1$species <- factor(lambda.allcombis.bootpara_c1$species, levels = sp_order)

lambda.allcombis.bootpara.bcpi_c2$species <- factor(lambda.allcombis.bootpara.bcpi_c2$species, levels = sp_order)
lambda.allcombis.bootpara_c2$species <- factor(lambda.allcombis.bootpara_c2$species, levels = sp_order)

# add an indication whether lambda is significantly different from 0, make CIs NA for non-significant lambdas with CIs smaller than the points 
# (just so the errorbars don't get printed: they are smaller than the points and show through because of reduced alpha), generate facting 
# variable to get daucar its own facet
lambda.allcombis.bootpara.bcpi_c1 <- lambda.allcombis.bootpara.bcpi_c1 %>%
  mutate(lambda_sig = if_else(lower_BCPI > 1 | upper_BCPI < 1, "sig.", "n-sig."),
         treat_comp_fact = factor(treat_comp, levels = c("bare", "vege")) %>% 
           relevel("vege"))
lambda.allcombis.bootpara_c1 <- lambda.allcombis.bootpara_c1 %>%
  mutate(lambda_sig = if_else(lower_CI > 1 | upper_CI < 1, "sig.", "n-sig."))

lambda.allcombis.bootpara.bcpi_c2 <- lambda.allcombis.bootpara.bcpi_c2 %>%
  mutate(lambda_sig = if_else(lower_BCPI > 1 | upper_BCPI < 1, "sig.", "n-sig."),
         treat_comp_fact = factor(treat_comp, levels = c("bare", "vege")) %>% 
           relevel("vege"))
lambda.allcombis.bootpara_c2 <- lambda.allcombis.bootpara_c2 %>%
  mutate(lambda_sig = if_else(lower_CI > 1 | upper_CI < 1, "sig.", "n-sig."))

# define position_dodge
posd <- position_dodge(width = 0.7) # position_dodge2(width = 0.7, preserve = "single")


# plot 1: ambient high site
png("plots/Fig2_PGRhiambi_20251027_census1.png", width = 17, height = 10, units="cm", res=800)

# use upper_BCPI_red here to prevent the error bars showing through for points with reduced opacity --> but only if the errorbars are shorter than the points (manually defined above)
ggplot(data = lambda.allcombis.bootpara.bcpi_c1[lambda.allcombis.bootpara.bcpi_c1$treat_warm == "ambi" & lambda.allcombis.bootpara.bcpi_c1$site == "hi",],
       aes(x = species, y = lambda, col = site_treat_combi, alpha = lambda_sig)) +
  geom_abline(intercept = 1, slope = 0, linetype = "dashed") +
  geom_errorbar(aes(ymin = lower_BCPI, ymax = upper_BCPI, group = treat_comp_fact), width = 0.2, position = posd) +
  geom_point(aes(group = treat_comp_fact), position = posd, size = 4, col = "white", fill = "white", alpha = 1) +
  geom_point(aes(shape = trend, group = treat_comp_fact), position = posd, size = 4, fill = "white", stroke = 1.5) +
  theme_bw() +
  theme(
    axis.title.x = element_blank(),
    axis.title.y = element_text(size = 14),
    axis.text = element_text(size = 12),
    axis.text.x = element_text(hjust = 1, vjust = 0.5, angle = 90, face = "italic"),
    #axis.ticks = element_blank(),
    legend.background = element_blank(), 
    legend.text = element_text(size = 12),
    legend.title = element_blank(),
    strip.background = element_blank(),
    legend.position = c(0.82, 0.95),  # move legend to top-right corner
    legend.justification = c(1, 1),
    legend.box = "vertical",  # combine legends vertically into a single box
    legend.box.background = element_rect(fill = "white", color = "black"),
    #legend.key.size = unit(1.5, "lines"),
    #legend.key.width = unit(1.5, "lines"),
    legend.spacing = unit(-0.5, "lines")
  ) +
  labs(y = expression(paste("Population growth rate ", lambda))) +
  scale_alpha_manual(values = c(0.5, 1)) +
  scale_x_discrete(labels = function(x) species_names[x]) +
  scale_color_manual(
    values = treat_combi_site_col,
    name = "Competition Treatment",  # Legend title
    labels = c("hi_bare.ambi" = "without competition", "hi_vege.ambi" = "with competition"),
    guide = guide_legend(order = 1)) +
  scale_shape_manual(
    values = c(19, 21),
    labels = c("grow" = expression(paste(lambda, " > 1")), "shrink" = expression(paste(lambda, " < 1"))),
    guide = guide_legend(order = 2)) +
  guides(alpha = "none") #+
  #facet_wrap(~daucar_facet, scales = "free")

dev.off()

png("plots/FigS_PGRhiambi_20251027_census2.png", width = 17, height = 10, units="cm", res=800)

# use upper_BCPI_red here to prevent the error bars showing through for points with reduced opacity --> but only if the errorbars are shorter than the points (manually defined above)
ggplot(data = lambda.allcombis.bootpara.bcpi_c2[lambda.allcombis.bootpara.bcpi_c2$treat_warm == "ambi" & lambda.allcombis.bootpara.bcpi_c2$site == "hi",],
       aes(x = species, y = lambda, col = site_treat_combi, alpha = lambda_sig)) +
  geom_abline(intercept = 1, slope = 0, linetype = "dashed") +
  geom_errorbar(aes(ymin = lower_BCPI, ymax = upper_BCPI, group = treat_comp_fact), width = 0.2, position = posd) +
  geom_point(aes(group = treat_comp_fact), position = posd, size = 4, col = "white", fill = "white", alpha = 1) +
  geom_point(aes(shape = trend, group = treat_comp_fact), position = posd, size = 4, fill = "white", stroke = 1.5) +
  theme_bw() +
  theme(
    axis.title.x = element_blank(),
    axis.title.y = element_text(size = 14),
    axis.text = element_text(size = 12),
    axis.text.x = element_text(hjust = 1, vjust = 0.5, angle = 90, face = "italic"),
    #axis.ticks = element_blank(),
    legend.background = element_blank(), 
    legend.text = element_text(size = 12),
    legend.title = element_blank(),
    strip.background = element_blank(),
    legend.position = c(0.82, 0.95),  # move legend to top-right corner
    legend.justification = c(1, 1),
    legend.box = "vertical",  # combine legends vertically into a single box
    legend.box.background = element_rect(fill = "white", color = "black"),
    #legend.key.size = unit(1.5, "lines"),
    #legend.key.width = unit(1.5, "lines"),
    legend.spacing = unit(-0.5, "lines")
  ) +
  labs(y = expression(paste("Population growth rate ", lambda))) +
  scale_alpha_manual(values = c(0.5, 1)) +
  scale_x_discrete(labels = function(x) species_names[x]) +
  scale_color_manual(
    values = treat_combi_site_col,
    name = "Competition Treatment",  # Legend title
    labels = c("hi_bare.ambi" = "w/o competition", "hi_vege.ambi" = "with competition"),
    guide = guide_legend(order = 1)) +
  scale_shape_manual(
    values = c(19, 21),
    labels = c("grow" = expression(paste(lambda, " > 1")), "shrink" = expression(paste(lambda, " < 1"))),
    guide = guide_legend(order = 2)) +
  guides(alpha = "none") #+
#facet_wrap(~daucar_facet, scales = "free")

dev.off()
       

# plot 2: warmed high site
hi_warm_c1 <- ggplot(data = lambda.allcombis.bootpara.bcpi_c1[lambda.allcombis.bootpara.bcpi_c1$treat_warm == "warm" & lambda.allcombis.bootpara.bcpi_c1$site == "hi",],
        aes(x = species, y = lambda, col = site_treat_combi, alpha = lambda_sig)) +
   geom_abline(intercept = 1, slope = 0, linetype = "dashed") +
   geom_errorbar(aes(ymin = lower_BCPI, ymax = upper_BCPI, group = treat_comp_fact), position = posd, width = 0.2, alpha = 1) +
   geom_point(aes(group = treat_comp_fact), position = posd, shape = 21, size = 6,
              fill = "white", colour = "white", alpha = 1, stroke = 0) +
   geom_point(aes(shape = trend, group = treat_comp_fact), position = posd, size = 4, fill = "white", stroke = 1.5) +
   theme_bw() +
   theme(
     axis.title.x = element_blank(),
     axis.title.y = element_text(size = 14),
     axis.text = element_text(size = 12),
     axis.text.x = element_blank(),
     axis.ticks = element_blank(),
     legend.background = element_blank(), 
     legend.text = element_text(size = 12),
     legend.title = element_blank(),
     strip.background = element_blank(),
     legend.position = c(0.82, 0.95),  # move legend to top-right corner
     legend.justification = c(1, 1),
     legend.box = "vertical",  # combine legends vertically into a single box
     legend.box.background = element_rect(fill = "white", color = "black"),
     #legend.key.size = unit(1.5, "lines"),
     #legend.key.width = unit(1.5, "lines"),
     legend.spacing = unit(-0.5, "lines")
     ) +
   labs(y = expression(paste("Population growth rate ", lambda))) +
   scale_alpha_manual(values = c(0.5, 1)) +
   scale_x_discrete(labels = function(x) species_names[x]) +
   scale_color_manual(
     values = treat_combi_site_col,
     labels = c("hi_bare.warm" = "w/o competition", "hi_vege.warm" = "with competition"),
     guide = guide_legend(order = 1)) +
    scale_shape_manual(
      values = c(19, 21),
      labels = c("grow" = expression(paste(lambda, " > 1")), "shrink" = expression(paste(lambda, " < 1"))),
      guide = guide_legend(order = 2)) +
   guides(alpha = "none") # , shape = "none"
 
#dev.off()

hi_warm_c2 <- ggplot(data = lambda.allcombis.bootpara.bcpi_c2[lambda.allcombis.bootpara.bcpi_c2$treat_warm == "warm" & lambda.allcombis.bootpara.bcpi_c2$site == "hi",],
                  aes(x = species, y = lambda, col = site_treat_combi, alpha = lambda_sig, shape = trend)) +
  geom_abline(intercept = 1, slope = 0, linetype = "dashed") +
  geom_errorbar(aes(ymin = lower_BCPI, ymax = upper_BCPI, group = treat_comp_fact), position = posd, width = 0.2, alpha = 1) +
  geom_point(aes(group = treat_comp_fact), position = posd, shape = 21, size = 6,
             fill = "white", colour = "white", alpha = 1, stroke = 0) +
  geom_point(aes(shape = trend, group = treat_comp_fact), position = posd, size = 4, fill = "white", stroke = 1.5) +
  theme_bw() +
  theme(
    axis.title.x = element_blank(),
    axis.title.y = element_text(size = 14),
    axis.text = element_text(size = 12),
    axis.text.x = element_blank(),
    axis.ticks = element_blank(),
    legend.background = element_blank(), 
    legend.text = element_text(size = 12),
    legend.title = element_blank(),
    strip.background = element_blank(),
    legend.position = c(0.82, 0.95),  # move legend to top-right corner
    legend.justification = c(1, 1),
    legend.box = "vertical",  # combine legends vertically into a single box
    legend.box.background = element_rect(fill = "white", color = "black"),
    #legend.key.size = unit(1.5, "lines"),
    #legend.key.width = unit(1.5, "lines"),
    legend.spacing = unit(-0.5, "lines")
  ) +
  labs(y = expression(paste("Population growth rate ", lambda))) +
  scale_alpha_manual(values = c(0.5, 1)) +
  scale_x_discrete(labels = function(x) species_names[x]) +
  scale_color_manual(
    values = treat_combi_site_col,
    labels = c("hi_bare.warm" = "w/o competition", "hi_vege.warm" = "with competition"),
    guide = guide_legend(order = 1)) +
  scale_shape_manual(
    values = c(19, 21),
    labels = c("grow" = expression(paste(lambda, " > 1")), "shrink" = expression(paste(lambda, " < 1"))),
    guide = guide_legend(order = 2)) +
  guides(alpha = "none") # , shape = "none"

# plot 3: ambient low site
lo_ambi_c1 <- ggplot(data = lambda.allcombis.bootpara.bcpi_c1[lambda.allcombis.bootpara.bcpi_c1$treat_warm == "ambi" & lambda.allcombis.bootpara.bcpi_c1$site == "lo",],
       aes(x = species, y = lambda, col = site_treat_combi, alpha = lambda_sig, shape = trend)) +
  geom_abline(intercept = 1, slope = 0, linetype = "dashed") +
  geom_errorbar(aes(ymin = lower_BCPI, ymax = upper_BCPI, group = treat_comp_fact), position = posd, width = 0.2, alpha = 1) +
  geom_point(aes(group = treat_comp_fact), position = posd, shape = 21, size = 6,
             fill = "white", colour = "white", alpha = 1, stroke = 0) +
  geom_point(aes(shape = trend, group = treat_comp_fact), position = posd, size = 4, fill = "white", stroke = 1.5) +
  theme_bw() +
  theme(
    axis.title.x = element_blank(),
    axis.title.y = element_text(size = 14),
    axis.text = element_text(size = 12),
    axis.text.x = element_text(hjust = 1, vjust = 0.5, angle = 90, face = "italic"),
    #axis.ticks = element_blank(),
    legend.background = element_blank(), 
    legend.text = element_text(size = 12),
    legend.title = element_blank(),
    strip.background = element_blank(),
    legend.position = c(0.82, 0.95),  # move legend to top-right corner
    legend.justification = c(1, 1),
    legend.box = "vertical",  # combine legends vertically into a single box
    legend.box.background = element_rect(fill = "white", color = "black"),
    #legend.key.size = unit(1.5, "lines"),
    #legend.key.width = unit(1.5, "lines"),
    legend.spacing = unit(-0.5, "lines")
  ) +
  labs(y = expression(paste("Population growth rate ", lambda))) +
  scale_alpha_manual(values = c(0.5, 1)) +
  scale_x_discrete(labels = function(x) species_names[x]) +
  scale_color_manual(
    values = treat_combi_site_col,
    name = "Competition Treatment",  # Legend title
    labels = c("lo_bare.ambi" = "w/o competition", "lo_vege.ambi" = "with competition"),
    guide = guide_legend(order = 1)) +
  scale_shape_manual(
    values = c(19, 21),
    labels = c("grow" = expression(paste(lambda, " > 1")), "shrink" = expression(paste(lambda, " < 1"))),
    guide = guide_legend(order = 2)) +
  guides(alpha = "none", shape = "none") +
  ylim(0, 30)


lo_ambi_c2 <- ggplot(data = lambda.allcombis.bootpara.bcpi_c2[lambda.allcombis.bootpara.bcpi_c2$treat_warm == "ambi" & lambda.allcombis.bootpara.bcpi_c2$site == "lo",],
                     aes(x = species, y = lambda, col = site_treat_combi, alpha = lambda_sig, shape = trend)) +
  geom_abline(intercept = 1, slope = 0, linetype = "dashed") +
  geom_errorbar(aes(ymin = lower_BCPI, ymax = upper_BCPI, group = treat_comp_fact), position = posd, width = 0.2, alpha = 1) +
  geom_point(aes(group = treat_comp_fact), position = posd, shape = 21, size = 6,
             fill = "white", colour = "white", alpha = 1, stroke = 0) +
  geom_point(aes(shape = trend, group = treat_comp_fact), position = posd, size = 4, fill = "white", stroke = 1.5) +
  theme_bw() +
  theme(
    axis.title.x = element_blank(),
    axis.title.y = element_text(size = 14),
    axis.text = element_text(size = 12),
    axis.text.x = element_text(hjust = 1, vjust = 0.5, angle = 90, face = "italic"),
    #axis.ticks = element_blank(),
    legend.background = element_blank(), 
    legend.text = element_text(size = 12),
    legend.title = element_blank(),
    strip.background = element_blank(),
    legend.position = c(0.82, 0.95),  # move legend to top-right corner
    legend.justification = c(1, 1),
    legend.box = "vertical",  # combine legends vertically into a single box
    legend.box.background = element_rect(fill = "white", color = "black"),
    #legend.key.size = unit(1.5, "lines"),
    #legend.key.width = unit(1.5, "lines"),
    legend.spacing = unit(-0.5, "lines")
  ) +
  labs(y = expression(paste("Population growth rate ", lambda))) +
  scale_alpha_manual(values = c(0.5, 1)) +
  scale_x_discrete(labels = function(x) species_names[x]) +
  scale_color_manual(
    values = treat_combi_site_col,
    name = "Competition Treatment",  # Legend title
    labels = c("lo_bare.ambi" = "w/o competition", "lo_vege.ambi" = "with competition"),
    guide = guide_legend(order = 1)) +
  scale_shape_manual(
    values = c(19, 21),
    labels = c("grow" = expression(paste(lambda, " > 1")), "shrink" = expression(paste(lambda, " < 1"))),
    guide = guide_legend(order = 2)) +
  guides(alpha = "none", shape = "none") +
  ylim(0, 30)


# plot 4: combined warmed and lo site plots

# combine the plots 

png("plots/FigS_PGRcombined_20251027_census1.png", width = 17, height = 17, units="cm", res=800)

hi_warm_c1 + 
  theme(plot.tag = element_text(face = "bold", size = 16)) +
  lo_ambi_c1 + 
  plot_layout(ncol = 1) +   
  plot_annotation(tag_levels = "A") + 
  theme(plot.tag = element_text(face = "bold", size = 16))

dev.off()

png("plots/FigS_PGRcombined_20251027_census2.png", width = 17, height = 17, units="cm", res=800)

hi_warm_c2 + 
  theme(plot.tag = element_text(face = "bold", size = 16)) +
  lo_ambi_c2 + 
  plot_layout(ncol = 1) +   
  plot_annotation(tag_levels = "A") + 
  theme(plot.tag = element_text(face = "bold", size = 16))

dev.off()

# ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
# GROWTH RATES & ELEVATION  ----
# ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

# define upper range edge (90th quantile based on Caphe data)
q9_focals <- data.frame(species = c("broere", "brapin", "cenjac", "daucar", "medlup",
                                    "plamed", "hypper", "salpra", "silvul", "scacol"),
                        q9 = c(1016, 1428, 1405, 1586, 1811, 1743, 1415, 1411, 2277, 1427))
  
# add to pop. growth rates, calculate difference to high site (2000 masl)
lambda.allcombis_c1_q9 <- lambda.allcombis_c1 %>%
  left_join(q9_focals, by = "species") %>%
  mutate(diff_q9 = 2000 - q9)

mod0 <- lm(lambda ~ diff_q9 * site_treat_combi, data = lambda.allcombis_c1_q9)
mod1 <- lm(lambda ~ diff_q9 + site_treat_combi, data = lambda.allcombis_c1_q9)
mod2 <- lm(lambda ~ site_treat_combi, data = lambda.allcombis_c1_q9)

anova(mod0, mod1)
anova(mod1, mod2)

summary(lm(lambda ~ diff_q9, data = lambda.allcombis_c1_q9[lambda.allcombis_c1_q9$site_treat_combi == "hi.vege.ambi",]))
summary(lm(lambda ~ diff_q9, data = lambda.allcombis_c1_q9[lambda.allcombis_c1_q9$site_treat_combi == "hi.bare.ambi",]))
summary(lm(lambda ~ diff_q9, data = lambda.allcombis_c1_q9))

ggplot(data = lambda.allcombis_c1_q9, aes(x = diff_q9, y = lambda, col = treat_combi)) +
  geom_point() +
  geom_smooth(method = lm) +
  facet_wrap(~site) +
  theme_bw()

ggplot(data = lambda.allcombis_c1_q9, aes(x = diff_q9, y = lambda)) +
  geom_point() +
  geom_smooth(method = lm) +
  #facet_wrap(~site) +
  theme_bw()

# ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
# TREATMENT EFFECTS  ----
# ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

### warming effect -------------------------------------------------------------

# Comparison of warmed vs. ambient growth rates to directly see the effect of warming ("future climate").

# prepare wide data frame for warming effect (only hi site) from lambda (use BCPIs directly, not bootstrapped lambdas)
lambda.allcombis_c1_hi_widewarm <- lambda.allcombis.bootpara.bcpi_c1 %>%
  filter(site == "hi") %>%
  dplyr::select(species, site, treat_warm, treat_comp, lambda, mean_bootstrap, lower_BCPI, upper_BCPI, lambda_sig) %>%
  mutate(treat_warm = factor(treat_warm, levels = c("ambi","warm"))) %>%
  pivot_wider(id_cols = c(species, site, treat_comp),
              names_from = treat_warm,
              values_from = c(lambda, mean_bootstrap, lower_BCPI, upper_BCPI, lambda_sig),
              names_glue = "{.value}.{treat_warm}",
              names_sort = TRUE)
    
# generate band around 1:1 line (+ 10%)
tol <- 0.10
rng <- range(lambda.allcombis_c1_hi_widewarm$lambda.ambi, lambda.allcombis_c1_hi_widewarm$lambda.warm, lambda.allcombis_c1_hi_widewarm$lower_BCPI.ambi, lambda.allcombis_c1_hi_widewarm$upper_BCPI.ambi, lambda.allcombis_c1_hi_widewarm$lower_BCPI.warm, lambda.allcombis_c1_hi_widewarm$upper_BCPI.warm, na.rm = TRUE)
pad <- diff(rng) * 0.08
lims <- c(rng[1] - pad, rng[2] + pad)
band <- data.frame(x = seq(lims[1], lims[2], length.out = 400))

lab_pad <- 0.04 * diff(lims) # where to place the in-figure labels


# plot ambient vs. warmed growth rate
png("plots/Fig3_PGRambivswarm_20251027_census1.png", width = 17, height = 10, units="cm", res=800)

ggplot(data = lambda.allcombis_c1_hi_widewarm ,
       aes(x = lambda.ambi, y = lambda.warm)) +
  geom_ribbon(data = band, inherit.aes = FALSE, aes(x = x, ymin = -Inf, ymax = x), fill = "#5B7D6D", alpha = 0.1) + # ymax = x * (1 - tol)
  geom_ribbon(data = band, inherit.aes = FALSE, aes(x = x, ymin = x, ymax = Inf), fill = "#C17C0F", alpha = 0.1) + # ymin = x * (1 + tol)
  #geom_ribbon(data = band, inherit.aes = FALSE, aes(x = x, ymin = x * (1 - tol), ymax = x * (1 + tol)), fill = "grey70", alpha = 0.35) +
  geom_abline(intercept = 0, slope = 1, linetype = "dashed") +
  geom_errorbar(aes(ymin = lower_BCPI.warm, ymax = upper_BCPI.warm),
                width = 0.12, linewidth = 0.5, alpha = 0.9) +
  geom_errorbarh(aes(xmin = lower_BCPI.ambi, xmax = upper_BCPI.ambi),
                 height = 0.12, linewidth = 0.5, alpha = 0.9) +
  # point underlay so bars don’t show through
  geom_point(fill = "white", colour = "white", size = 4) +
  geom_point(colour = "black", fill = "black",
             size = 4, alpha = 0.7) +
  theme_bw() +
  facet_grid(~ treat_comp, labeller = as_labeller(c("bare" = "without competition", "vege" = "with competition"))) + # , scales = "free"
  theme(
    axis.title = element_text(size = 14),
    axis.text = element_text(size = 12),
    strip.background = element_blank(),
    strip.text = element_text(size = 14)
  ) +
  labs(x = expression(paste("Population growth rate ", lambda, " (ambient)")),
       y = expression(paste("Population growth rate ", lambda, " (warmed)"))) +
  coord_equal(xlim = lims, ylim = lims, expand = FALSE) +
  annotate("text", x = lims[1] + lab_pad, y = lims[2] - lab_pad,
           label = "warming increases \u03BB", hjust = 0, vjust = 1,
           size = 5, colour = "#C17C0F", fontface = "bold") +
  annotate("text", x = lims[2] - lab_pad, y = lims[1] + lab_pad,
           label = "warming decreases \u03BB", hjust = 1, vjust = 0,
           size = 5, colour = "#5B7D6D", fontface = "bold") 

dev.off()

# prepare wide data frame for warming effect (both comp treatments) for lambdas and calculate difference warm - ambi
lambda.allcombis_c1_diffwarm  <- lambda.allcombis_c1 %>%
  filter(site == "hi") %>%
  dplyr::select(species, site, treat_warm, treat_comp, lambda) %>%
  pivot_wider(names_from  = treat_warm,
              values_from = lambda) %>%
  mutate(delta_lambda = warm - ambi, # absolute difference
         lrr_lambda   = log(ambi) - log(warm), # log response ratio
         pct_change_rel_bare = 100 * (ambi - warm) / warm) # percentage change in lambda relative to bare

mod <- lmerTest::lmer(lrr_lambda ~ as.factor(treat_comp) + (1|species), data = lambda.allcombis_c1_diffwarm)
summary(mod)

mod0 <- lmerTest::lmer(lambda ~ as.factor(treat_warm)  * as.factor(treat_comp) + (1|species), data = lambda.allcombis_c1[lambda.allcombis_c1$site == "hi",])
mod1 <- lmerTest::lmer(lambda ~ as.factor(treat_warm)  + as.factor(treat_comp) + (1|species), data = lambda.allcombis_c1[lambda.allcombis_c1$site == "hi",])
mod2 <- lmerTest::lmer(lambda ~ as.factor(treat_warm)  + (1|species), data = lambda.allcombis_c1[lambda.allcombis_c1$site == "hi",])
mod3 <- lmerTest::lmer(lambda ~ as.factor(treat_comp) + (1|species), data = lambda.allcombis_c1[lambda.allcombis_c1$site == "hi",])

anova(mod0, mod1)
anova(mod1, mod2)
anova(mod1, mod3)

summary(mod1)


### competition effect ---------------------------------------------------------

# goal: quantifying how strongly competition affects population growth rates in each warming treatment, while correctly propagating both within-species and among-species uncertainty

# 1) prepare the data frames for hierarchical bootstrapping

# set order for plotting 
site_order <- c("hi.ambi","hi.warm","lo.ambi")

# prepare wide data frame for competition effect (both sites) for bootstrapped lambdas and calculate difference bare - vege
lambda_bootpara_c1_diffcomp <- lambda_bootpara_c1 %>%
  dplyr::select(species, site, treat_warm, treat_comp, bootstrap, lambda) %>%
  pivot_wider(names_from  = treat_comp,
              values_from = lambda) %>%
  mutate(delta_lambda = bare - vege, # absolute difference
         lrr_lambda   = log(vege) - log(bare), # log response ratio
         pct_change_rel_bare = 100 * (vege - bare) / bare) %>% # percentage change in lambda relative to bare
  mutate(site_warm = paste(site, treat_warm, sep = "."),
         site_warm = factor(site_warm, levels = site_order)) %>%
  dplyr::select(species, site_warm, bootstrap, lrr_lambda)

# do the same for "real" lambdas
lambda.allcombis_c1_diffcomp  <- lambda.allcombis_c1 %>%
  dplyr::select(species, site, treat_warm, treat_comp, lambda) %>%
  pivot_wider(names_from  = treat_comp,
              values_from = lambda) %>%
  mutate(delta_lambda = bare - vege, # absolute difference
         lrr_lambda   = log(vege) - log(bare), # log response ratio
         pct_change_rel_bare = 100 * (vege - bare) / bare) %>% # percentage change in lambda relative to bare
  mutate(site_warm = paste(site, treat_warm, sep = "."),
         site_warm = factor(site_warm, levels = site_order)) %>%
  dplyr::select(species, site_warm, lrr_lambda)

# 2) hierarchical bootstrap on lrr

#   - resample species with replacement
#   - within each species x warming treatment, sample one paired lrr draw (by bootstrap id)
#   - average across species to get warming treatment mean for that iteration

# --> negative means competition reduces lambda

# run the bootstrap (species sampled withput replacement!)
boot_lambda_bootpara_c1 <- lambda_bootpara_c1_diffcomp %>%
  filter(site_warm %in% site_order) %>%
  select(species, site_warm, bootstrap, lrr_lambda) %>%
  hier_bootstrap_lrr(B = 5000, seed = 2025) %>%
  mutate(site_warm = factor(site_warm, levels = site_order))


# 3) summaries and pairwise contrasts

# summarize the bootstrapped comp. effects
env_summary <- boot_lambda_bootpara_c1 %>%
  group_by(site_warm) %>%
  summarise(
    mean = mean(mean_lrr),
    lwr  = quantile(mean_lrr, 0.025),
    upr  = quantile(mean_lrr, 0.975),
    pd_neg = mean(mean_lrr < 0), # proportion of bootstrap means < 0
    pd_pos = mean(mean_lrr > 0), # proportion of bootstrap means > 0
    .groups = "drop")

# make wide to calculate the differences between the warming treattments (hi ambi vs. lo ambi, hi warm vs. hi ambi, hi warm vs. lo ambi)
boot_lambda_bootpara_c1_wide <- boot_lambda_bootpara_c1 %>%
  dplyr::select(iter, site_warm, mean_lrr) %>%
  pivot_wider(names_from = site_warm, values_from = mean_lrr)

n <- nrow(boot_lambda_bootpara_c1_wide) # how many bootstraps?

contrasts <- tibble(
  contrast = rep(c("lo.ambi − hi.ambi",
                   "hi.warm − hi.ambi",
                   "lo.ambi − hi.warm"), each = n),
  diff = c(
    boot_lambda_bootpara_c1_wide$`lo.ambi` - boot_lambda_bootpara_c1_wide$`hi.ambi`,
    boot_lambda_bootpara_c1_wide$`hi.warm` - boot_lambda_bootpara_c1_wide$`hi.ambi`,
    boot_lambda_bootpara_c1_wide$`lo.ambi` - boot_lambda_bootpara_c1_wide$`hi.warm`)) %>%
  group_by(contrast) %>%
  summarise(
    mean  = mean(diff, na.rm = TRUE),
    lwr   = quantile(diff, 0.025, na.rm = TRUE),
    upr   = quantile(diff, 0.975, na.rm = TRUE),
    pd_neg = mean(diff < 0, na.rm = TRUE),
    pd_pos = mean(diff > 0, na.rm = TRUE),
    .groups = "drop")

# 4) calculate per-species uncertainity around the lrr (per-species 95% ci for lrr from the bootstrap draws)
sp_cis <- lambda_bootpara_c1_diffcomp %>%
  group_by(site_warm, species) %>%
  summarise(
    lwr_sp = quantile(lrr_lambda, 0.025, na.rm = TRUE),
    upr_sp = quantile(lrr_lambda, 0.975, na.rm = TRUE),
    .groups = "drop")

# join to your species points (real lrrs)
lambda.allcombis_c1_diffcomp_bootparaCI <- lambda.allcombis_c1_diffcomp %>%
  filter(site_warm %in% c("hi.ambi","hi.warm","lo.ambi")) %>%
  distinct(species, site_warm, lrr_lambda) %>%
  left_join(sp_cis, by = c("site_warm","species"))


# 4) plot (species "real" lambdas plus the warming treatment means and CIs from the hierachical bootstrapping)

# y-axis is lrr_lambda = ln(lambda_with_comp) − ln(lambda_no_comp)

# site labels
site_labels <- c("hi.ambi" = "high ambient (above-range)", "hi.warm" = "high warmed (above-range)", "lo.ambi" = "low ambient (within-range)")

# make one shared position object so both geoms use the same jitter
pos_sp <- position_dodge(width = 0.3) # position_dodge2(width = 0.7, preserve = "single")

# define reference levels to simplyfy reading LRR
lrr_zero  <- 0 # 0% change
lrr_half   <- log(0.5)  # −0.693 = 50% decrease with competition
lrr_double <- log(2)    #  +0.693 = 100% increase (facilitation)
# shaded band: between half and double ([-log2, +log2])
band_lo <- log(0.5)
band_hi <- log(2)

# plot
plot_comp_effect <- ggplot() +
  annotate("rect", xmin = -Inf, xmax = Inf, ymin = band_lo, ymax = band_hi,
           fill = "grey80", alpha = 0.25) +
  # reference lines
  geom_hline(yintercept = c(lrr_zero, lrr_double, lrr_half),
             linetype = c("dashed","dotted","dotted"), linewidth = c(.5,.4,.4),
             color = "black") +
  # species ci (thin) + species point (red), both with the same jitter
  geom_errorbar(data = lambda.allcombis_c1_diffcomp_bootparaCI,
                aes(x = site_warm, ymin = lwr_sp, ymax = upr_sp, group = species),
                width = 0.4, alpha = 0.8, position = pos_sp, colour = "grey40") +
  geom_point(data = lambda.allcombis_c1_diffcomp_bootparaCI,
             aes(x = site_warm, y = lrr_lambda, group = species),
             position = pos_sp, alpha = 0.8, size = 2, color = "grey40") +
  geom_hline(yintercept = 0, linetype = 2) +
  geom_linerange(data = env_summary,
                 aes(x = site_warm, ymin = lwr, ymax = upr), col = "white",
                 linewidth = 1.4) +
  geom_linerange(data = env_summary,
                 aes(x = site_warm, ymin = lwr, ymax = upr, col = site_warm),
                 linewidth = 1.2) +
  geom_point(data = env_summary,
             aes(x = site_warm, y = mean), col = "white",
             size = 4.5) +
  geom_point(data = env_summary,
             aes(x = site_warm, y = mean, col = site_warm),
             size = 4) +
   theme_bw() +
  theme(
    axis.title.x = element_blank(),
    axis.title.y = element_text(size = 14),
    axis.text = element_text(size = 12),
    axis.text.x = element_text(face = "italic", angle = 90, hjust = 1, vjust = 0.5),
    #axis.ticks = element_blank(),
    #legend.background = element_blank(), 
    #legend.text = element_text(size = 11),
    #legend.title = element_blank(),
    strip.background = element_blank(),
    ) +
  labs(y = expression(atop("Competition effect",
                           log(lambda[plain("with competition")]/lambda[plain("w/o competition")])))) +
  scale_x_discrete(labels = c("above-range\n (ambient)", "above-range\n (warmed)", "within-range\n (ambient)")) +
  scale_color_manual(values = treat_warm_site_col, 
                     name = "Site & warming treatment", 
                     labels = c("lo.ambi" = "within-range, ambient", "hi.ambi" = "beyond-range, ambient", "hi.warm" = "beyond-range, warmed"),
                     guide = guide_legend(order = 1)) +
  guides(colour = "none")

png("plots/Fig4a_PGRbarevsvege_20251027_census1.png", width = 10, height = 10, units="cm", res=800)

plot_comp_effect

dev.off()


# ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
# STARTING POPULATION SIZE  ----
# ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

### find starting pop. size ----------------------------------------------------

# find starting population size for "real" IPM kernels with 1 individual in smallest size class

# use vital rate parametrs to directly calculate the number of requires individuals in the smallest size class plus the germination and seedling estabslishment rate
# unique combinations of species, site, and treatment
sst_combinations <- vr_long %>%
  distinct(species, site, treat_combi)

# transform the vital rate coefficients into a list 
params_list <- mk.params.list(data_vrcols = vr_long, data_sstcombi = sst_combinations)

# define number of meshpoints
n_mesh <- 500

# loop over params and compute required seeds
keys <- names(params_list)
res_list <- vector("list", length(keys))

for (i in seq_along(keys)) {
  
  # get current key and parametres
  key <- keys[i]
  par <- params_list[[key]]
  
  # use function to calculate required_sc1 and p_seed_to_sc1 (probability of seed to smallest size class)
  out <- required_seeds_from_params(par, n_mesh, target_pop_size = 5000, nstep = 10, sc1_index = 1)
  res_list[[i]] <- data.frame(
    species_site_treat = key,
    gT = out$gT, required_sc1 = out$required_sc1,
    required_seeds = out$required_seeds, p_seed_to_sc1 = out$p_seed_to_sc1,
    note = NA_character_
  )
}

required_seeds_sc1_params <- do.call(rbind, res_list)


### plamed vs. daucar ----------------------------------------------------------

# why does plamed need so many more seeds than daucar?

# 1) ...because of a) the seed-to-seedling transition or because of b) seedling to more individuals?

# define the two species we want to compare
k_plamed <- "plamed_hi_vege.ambi" 
k_daucar <- "daucar_hi_vege.ambi"

# calcuate the transition form seed to establsihed seedling p(seed->sc1)
p_plamed <- plogis(params_list[[k_plamed]]$germ.int) * plogis(params_list[[k_plamed]]$est.int)
p_daucar <- plogis(params_list[[k_daucar]]$germ.int) * plogis(params_list[[k_daucar]]$est.int)

# calculate the no. of adults (g10) per 1 sc1 
g10 <- function(par, n_mesh) {
  K <- mk.kernel(L=par$L, U=par$U, par=par, n=n_mesh)$K
  required_sc1_simple(1, K, nstep=10)$gT   
}

g10_plamed <- g10(params_list[[k_plamed]], n_mesh)
g10_daucar <- g10(params_list[[k_daucar]], n_mesh)

# get the contributions on the log scale
d_log_S  <- log(5000/(g10_plamed*p_plamed)) - log(5000/(g10_daucar*p_daucar))
contr_est <- -(log(p_plamed) - log(p_daucar))
contr_dyn <- -(log(g10_plamed) - log(g10_daucar))

c(total_gap_log = d_log_S, from_establishment = contr_est, from_post_est_dynamics = contr_dyn)

# the difference between daucar and plamed is mostly based on post-establishment dynamics
# total gap: 14.69 --> plamed needs exp(14.69) = 2397651 seeds to get to 5000 individuals after 10 years
# gap due to seed->sedling: 1.079 --> exp(1.079) = 2.941736 of the gap (i.e. 1.079/14.69 = 7%)
# gap due to griwth to adult: 13.609493 --> 813818.8 of the gap (i.e. 13.609/14.69 = 93%)

# On the log (additive) scale, about 7 % of the difference in required seeds between plamed and 
# daucar is due to germination + establishment, and 93 % is due to post-establishment dynamics.

# 2) ...if it's because of post-establishment dynamics (i.e. b)): because of survival/ growth (G) or fecundity (R)?

# set up function to exchange G and R for plamed and daucar
mix_test <- function(parA, parB, n_mesh) {
  KA <- mk.kernel(L=parA$L, U=parA$U, par=parA, n=n_mesh)
  KB <- mk.kernel(L=parB$L, U=parB$U, par=parB, n=n_mesh)
  
  g10_from <- function(K) required_sc1_simple(1, K, nstep=10)$gT
  
  g10_A     <- g10_from(KA$K)                 # baseline A
  g10_P_A_R_B <- g10_from(KA$G + KB$R)        # A’s survival-growth + B’s fecundity
  g10_P_B_R_A <- g10_from(KB$G + KA$R)        # B’s survival-growth + A’s fecundity
  
  tibble(
    g10_A      = g10_A,
    g10_with_Bfec = g10_P_A_R_B,   # how much A improves if it had B's fecundity
    g10_with_Bsg  = g10_P_B_R_A    # how much A improves if it had B's survival-growth
  )
}

mix <- mix_test(params_list[["plamed_hi_vege.ambi"]], params_list[["daucar_hi_vege.ambi"]], n_mesh)
mix

# baseline plamed no. individuals after 10 years when start with 1 seedling in smallest size class: 0.0786
# ... if given daucars growth/survival kernel: 0.158 --> ~2x increase in g10
# ... if given daucars fecundity kernel: 900 --> ~11,450× increase in g10

### bootstrap staring pop. size ------------------------------------------------

# done in cluster, load cluster results --> loaded together with bootstrapped lambdas
required_seeds_sc1_params_boot <- lambda_popsize_bootpara_c1 %>%
  dplyr::select(- lambda)
  
# define which species from hi site vege.ambi have PGR >= 1
spec_startposize <- lambda.allcombis_c1 %>%
  filter(lambda >= 1 & site == "hi" & treat_combi == "vege.ambi")
unique(spec_startposize$species)
spec_startposize <- c("daucar", "medlup", "cenjac", "hypper", "plamed", "broere")

# extract only hi site vege.ambi data and the species with PGR >= 1
required_seeds_sc1_params_boot <- required_seeds_sc1_params_boot %>%
  mutate(species = str_sub(parameter_name, 1, 6),
         site = str_sub(parameter_name, 8, 9),
         treat_combi = str_sub(parameter_name, 11, 19)) 
popsize_bootpara_selected <- required_seeds_sc1_params_boot %>%
  filter(site == "hi" & treat_combi == "vege.ambi" & species %in% spec_startposize) %>%
  mutate(required_seeds_log = log(required_seeds),
         required_sc1_log = log(required_sc1))

# are there negative values?
min(popsize_bootpara_selected$required_sc1, na.rm = TRUE) # nope (NAs are from lambdas < 1, for which the starting population wasn't calculated)

# make a long data frame
popsize_bootpara_selected_long <- popsize_bootpara_selected %>%
  pivot_longer(cols = starts_with("required"), 
               names_to = "type", 
               values_to = "n0")

# calculate uncorrected confidence intervals of the raw values and the logged values
popsize.allcombis.bootpara <- popsize_bootpara_selected %>%
  filter(is.na(required_seeds) == FALSE, is.na(required_sc1) == FALSE) %>% # get rid of NA's (the bootstrapped lambdas are not all >= 1 just because the "real" value is)
  group_by(site, species, treat_combi) %>%
  summarize(boot_mean_seeds = mean(required_seeds),
            lower_CI_seeds = quantile(required_seeds, 0.025),
            upper_CI_seeds = quantile(required_seeds, 0.975),
            lower_CI_seeds_log = quantile(required_seeds_log, 0.025),
            upper_CI_seeds_log = quantile(required_seeds_log, 0.975),
            boot_mean = mean(required_sc1),
            lower_CI = quantile(required_sc1, 0.025),
            upper_CI = quantile(required_sc1, 0.975),
            lower_CI_log = quantile(required_sc1_log, 0.025),
            upper_CI_log = quantile(required_sc1_log, 0.975)) %>%
  ungroup() 

# calculate bias corrected confidence intervals of "real" starting pop sizes --> only for species for which their PGR > 1
alpha <- 0.05

popsize.allcombis.bootpara.bcpi <- popsize_bootpara_selected %>%
  filter(is.na(required_seeds) == FALSE, is.na(required_sc1) == FALSE) %>% # get rid of NA's (the bootstrapped lambdas are not all >= 1 just because the "real" value is)
  filter(species %in% spec_startposize) %>%
  group_by(species, site, treat_combi) %>%
  summarise(
    dplyr::across(
      c(required_sc1, required_seeds, required_sc1_log, required_seeds_log, gT, p_seed_to_sc1),
      ~ list(.x), # collect values per group into a vector
      .names = "boot_{.col}"), .groups = "drop") %>%
  ungroup() %>%
  mutate(species_site_treat = paste(species, site, treat_combi, sep = "_")) %>%
  left_join(required_seeds_sc1_params, by = c("species_site_treat")) %>%
  mutate(required_sc1_log = log(required_sc1),
         required_seeds_log = log(required_seeds)) %>%
  mutate(bcpi_CI = map2(required_sc1, boot_required_sc1, ~ bcpi(.x, .y, alpha)),  # .x = required_n0, .y = bootstrapped_values
         lower_BCPI = sapply(bcpi_CI, `[[`, 1),  
         upper_BCPI = sapply(bcpi_CI, `[[`, 2),
         mean_bootstrap = sapply(boot_required_sc1, mean),
         bcpi_CI_seeds = map2(required_seeds, boot_required_seeds, ~ bcpi(.x, .y, alpha)),  # .x = required_n0, .y = bootstrapped_values
         lower_BCPI_seeds = sapply(bcpi_CI_seeds, `[[`, 1),  
         upper_BCPI_seeds = sapply(bcpi_CI_seeds, `[[`, 2),
         mean_bootstrap_seeds = sapply(boot_required_seeds, mean),
         bcpi_CI_log = map2(required_sc1_log, boot_required_sc1_log, ~ bcpi(.x, .y, alpha)),  # .x = required_n0, .y = bootstrapped_values
         lower_BCPI_log = sapply(bcpi_CI_log, `[[`, 1),  
         upper_BCPI_log = sapply(bcpi_CI_log, `[[`, 2),
         mean_bootstrap_log = sapply(boot_required_sc1_log, mean),
         bcpi_CI_seeds_log = map2(required_seeds_log, boot_required_seeds_log, ~ bcpi(.x, .y, alpha)),  # .x = required_n0, .y = bootstrapped_values
         lower_BCPI_seeds_log = sapply(bcpi_CI_seeds_log, `[[`, 1),  
         upper_BCPI_seeds_log = sapply(bcpi_CI_seeds_log, `[[`, 2),
         mean_bootstrap_seeds_log = sapply(boot_required_seeds_log, mean)) %>%
  ungroup() %>%
  mutate(treat_warm = str_sub(treat_combi, 6, 9),
         treat_comp = str_sub(treat_combi, 1,4),
         treat_warm_site = paste(site, treat_warm, sep = "_"), 
         site_treat_combi = factor(paste(site, treat_combi, sep = "_"), levels = c("lo_bare.ambi", "lo_vege.ambi", "hi_bare.ambi", "hi_vege.ambi", "hi_bare.warm", "hi_vege.warm"))) %>%
  ungroup()

# now plot with log scale

# re-order species
popsize.allcombis.bootpara.bcpi$species <- factor(popsize.allcombis.bootpara.bcpi$species, levels = spec_startposize)
popsize_bootpara_selected_long$species <- factor(popsize_bootpara_selected_long$species, levels = spec_startposize)

# plot
png("plots/Fig4b_SPShiambi_20250127.png",  width = 10, height = 10, units="cm", res=800)

ggplot(data = popsize.allcombis.bootpara.bcpi, 
                        aes(x = species, y = required_seeds)) +
  scale_x_discrete(labels = function(x) species_names[x]) +
  geom_jitter(data = popsize_bootpara_selected, 
              aes(x = species, y = required_seeds), col = "lightgray", width = 0.3) +
  geom_point(position = position_dodge(width = 0.7), col = "#5B7D6D", size = 3) +
  geom_errorbar(aes(ymin = lower_BCPI_seeds, ymax = upper_BCPI_seeds), width = 0.2, position = position_dodge(width = 0.7), col = "#5B7D6D") +
  theme_bw() +
  theme(
    axis.title.x = element_blank(),
    axis.title.y = element_text(size = 14),
    axis.text = element_text(size = 12),
    axis.text.x = element_text(hjust = 1, vjust = 0.3, angle = 90, face = "italic"),
    #axis.ticks = element_blank(),
    legend.background = element_blank(), 
    legend.text = element_text(size = 12),
    legend.title = element_blank(),
    strip.background = element_blank(),
    legend.position = c(0.95, 0.95),  # move legend to top-right corner
    legend.justification = c(1, 1),
    legend.box = "vertical",  # combine legends vertically into a single box
    legend.box.background = element_rect(fill = "white", color = "black"),
    #legend.key.size = unit(1.5, "lines"),
    #legend.key.width = unit(1.5, "lines"),
    legend.spacing = unit(-0.5, "lines")) +
  labs(y = "Number of seeds") +
  #facet_wrap(~ species, scales = "free") +
  #geom_abline(intercept = 10, slope = 0, col = "blue") +
  #geom_abline(intercept = 100, slope = 0, col = "red") +
  #geom_abline(intercept = 110, slope = 0, col = "green") +
  #scale_y_continuous(trans = "symlog") +
  scale_y_log10(
    breaks = scales::trans_breaks("log10", function(x) 10^x),
    labels = scales::trans_format("log10", scales::math_format(10^.x))) #+

dev.off()
